<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMake</title>
      <link href="/2024/08/09/C++/CMake%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/08/09/C++/CMake%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake是什么"><a href="#CMake是什么" class="headerlink" title="CMake是什么"></a>CMake是什么</h1><p>​CMake是Cross Platform Make的缩写，CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他并不能直接生成最终的应用程序，而是产生标准的建构档。CMake使用更高级的工程组织工具，可以避免直接编写底层的makefile文件，使得工程构建和编译变得更加方便快捷。</p><p>  CMake是通过CMakeLists.txt文件进行工程构建的，只需要编写CMakeLists.txt文件，对编译构成进行配置。同时一个路径下只能有一个CMakeLists.txt文件，因为CMake工具在进行工程构建的过程中，会自动在执行路径中进行CMakeLists.txt文件的查找。</p><p>​下载链接<a href="https://cmake.org/download/">https://cmake.org/download/</a></p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>在目录下编写CMakeLists.txt，根据CMake语法对源码进行编排依赖，生成Makefile，编译生成可执行文件</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required"></a>cmake_minimum_required</h2><p>作用：设置所需cmake的最低版本</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;max&gt;] [FATAL_ERROR])</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br></pre></td></tr></table></figure><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>作用：用于指定cmake工程的名称，实际上，还可以指定cmake工程的版本号（<code>VERSION</code>关键字）、简短的描述（<code>DESCRIPTION</code>关键字）、主页URL（<code>HOMEPAGE_URL</code>关键字）和编译工程使用的语言（<code>LANGUAGES</code>关键字）</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">              [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">              [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">              [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">              [LANGUAGES &lt;language-name&gt;...])</span><br><span class="line">              </span><br><span class="line"><span class="keyword">project</span> (mytest VERSION <span class="number">1.2</span>.<span class="number">3.4</span> LANGUAGES “CXX”)</span><br></pre></td></tr></table></figure><h2 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h2><p>作用：收集指定路径下所有源文件的文件名，并将这些文件名存储在指定的变量中。配合add_executable使用</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SOURCES)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>作用：用于对文件和目录进行操作，可以满足各种不同的需求，这里只记录与aux_source_directory类似的功能，其余的功能查看官网内容</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径或文件类型)</span><br><span class="line">GLOB和GLOB_RECURSE来查找符合指定模式的文件和目录；GLOB选项值匹配当前目录下的文件或目录，而GLOB_RECURSE选项则递归查找所有子目录中的文件和目录。</span><br><span class="line">第二个参数是将搜索的结果赋值给变量</span><br><span class="line">第三个参数是指定文件路径或文件后缀类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCES <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(main SOURCES)</span><br></pre></td></tr></table></figure><h2 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable"></a>add_executable</h2><p>作用：用于创建可执行文件目标的命令。它指定了可执行文件的名称及其所需的源文件</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span><br><span class="line">                  [EXCLUDE_FROM_ALL]</span><br><span class="line">                  [source1] [source2 ...])</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp <span class="keyword">test</span>.cpp)</span><br></pre></td></tr></table></figure><h2 id="aux-source-directory-1"><a href="#aux-source-directory-1" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h2><p>作用：查找在某个路径下的所有源文件，避免add_executable添加很多源文件</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到变量SOURCES中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SOURCES)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="add-compile-options"><a href="#add-compile-options" class="headerlink" title="add_compile_options"></a>add_compile_options</h2><p>作用：用于为整个项目的所有源文件添加编译选项。这些编译选项将应用于所有源文件，无论它们是否属于同一个目标（如库或可执行文件）</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(&lt;options&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成调试信息</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-g)</span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">17</span>)</span><br></pre></td></tr></table></figure><h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories"></a>include_directories</h2><p>作用：用于向编译器添加头文件搜索路径。当你的项目中包含的头文件不在编译器默认搜索的路径中时，你就需要使用这个命令来指明额外的头文件位置</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])</span><br><span class="line">AFTER 或 BEFORE：可选参数，用来指定添加的路径应该放在其他已包括路径的前面还是后面。如果不指定，默认是 AFTER。</span><br><span class="line">SYSTEM：可选参数，标记添加的路径为系统包含路径，这主要影响警告的处理方式。通常，编译器不会对系统头文件中的警告进行报告。</span><br><span class="line">dir1 [dir2 ...]：要添加的头文件搜索路径列表。</span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;PROJECT_SOURCE_DIR&#125;/include会被添加到其他已包含路径的前面，并且被标记为系统路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(BEFORE SYSTEM <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h2 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories"></a>target_include_directories</h2><p>作用：用于向特定目标（如可执行文件或库）添加包含目录，以便编译器能够找到特定目标所需的头文件。提供更好的依赖管理和封装性。</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])</span><br><span class="line">target_name：目标名称，可以是通过 <span class="keyword">add_executable</span> 或 <span class="keyword">add_library</span> 定义的可执行文件或库的名称。</span><br><span class="line">SYSTEM：可选参数，用于将指定的目录标记为系统包含目录，避免编译器产生警告。</span><br><span class="line">BEFORE：可选参数，将指定的目录添加到已有的包含目录前面。</span><br><span class="line">directory1, directory2, …：要添加到目标的包含目录列表。这些可以是绝对路径或相对于CMakeLists.txt 文件的相对路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h2 id="add-library"><a href="#add-library" class="headerlink" title="add_library"></a>add_library</h2><p>作用：用于向项目添加一个库文件，并定义其类型（静态库或共享库）。这个命令是管理库文件的主要方法之一，用于指定源文件、依赖项和其他相关设置。</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(target_name [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1[source2 ...])</span><br><span class="line">target_name: 库文件的名称，通常是不带扩展名的名字，如 my_library。</span><br><span class="line">[STATIC | SHARED | MODULE]: 指定库文件的类型，可选参数。默认为 STATIC 静态库。</span><br><span class="line">STATIC: 静态库，会被链接到其他目标的可执行文件中。</span><br><span class="line">SHARED: 共享库（动态库），在运行时动态加载到内存中。</span><br><span class="line">MODULE: 在某些平台上的插件库类型。</span><br><span class="line">[EXCLUDE_FROM_ALL]: 可选参数，如果设置，则将该库文件排除在 make all 或 build 目标之外。</span><br><span class="line">source1, source2, …: 库文件的源文件列表，可以是源文件的路径或变量。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib STATIC library.cpp <span class="keyword">test</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib SHARED library.cpp <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="comment"># 设置动态库的版本号，VERSION 表示库的版本，SOVERSION 表示库的主版本号。</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(my_lib PROPERTIES VERSION <span class="number">1.2</span>.<span class="number">3</span> SOVERSION <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="target-link-directories"><a href="#target-link-directories" class="headerlink" title="target_link_directories"></a><strong>target_link_directories</strong></h2><p>作用：用于在构建目标时链接库文件</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_directories</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">[&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])xxxxxxxxxx <span class="keyword">target_link_directories</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...][&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib SHARED library.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_directories</span>(main my_lib)</span><br></pre></td></tr></table></figure><h2 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h2><p>作用：用于向当前项目添加一个子目录，并且使得 CMake 在构建过程中进入该子目录继续处理其中的 CMakeLists.txt 文件。这个命令通常用于管理项目中的多个模块或子项目。</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line">source_dir: 指定要添加的子目录的路径。</span><br><span class="line">binary_dir: 指定要生成的二进制文件的路径。如果未指定，将使用默认的二进制文件目录（即在构建目录下的 source_dir 子目录）。</span><br><span class="line">EXCLUDE_FROM_ALL: 可选参数，如果设置，则将该子目录排除在 make all 或 build 目标之外。</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2024/06/01/C++/STL/"/>
      <url>/2024/06/01/C++/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>增大或缩小容器实际存储的元素的数量</p><p>resize只会改变实际存储的元素的数量，并不会改变容器的最大容量，即容器的capacity</p><p>1、如果resize指定的值小于当前容器的实际存储的元素的数量，则多出来的元素都会被删除（<strong>这里的删除是逻辑上的删除，因为还可以访问到</strong>）</p><p>2、如果大于当前容器的实际存储的元素数量，则会添加新的元素进行补充，按照指定的值或者容器进行值初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 5</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;has delete:&quot;</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;new value:&quot;</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;endl; <span class="comment">// 9</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">8</span>); <span class="comment">// 超过当前元素个数，分配默认值为0 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Default initialization:&quot;</span>&lt;&lt;v[<span class="number">7</span>]&lt;&lt;endl; <span class="comment">// 0</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 8</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">11</span>,<span class="number">1</span>); <span class="comment">// 超过当前元素个数，设置了默认值为1 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;designated value:&quot;</span>&lt;&lt;v[<span class="number">10</span>]&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h2><p>只适用于vector和string。</p><p>reserve(n)：分配至少能容纳n个元素的内存空间，reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间，即改变的是capacity。</p><p>1、只有当 n 大于当前的容量时，才会改变容器的容量，reserve至少分配与需求一样大的内存空间，也可能更大</p><p>2、当n小于或者等于当前容量时，reserve什么也不做，容器也不会退回内存空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 5 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 5</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 8</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">3</span>); <span class="comment">// 3小于8，不会改变容量大小 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit"></a>shrink_to_fit</h2><p>只适用于vector，string和deque</p><p>退回不需要的内存空间，将capacity减少为与size相同大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 5 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 5</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;<span class="comment">// 6</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 10</span></span><br><span class="line">    v.<span class="built_in">shrink_to_fit</span>(); <span class="comment">// 退回没有使用的空间，容量和size大小一致 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 6</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl; <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="set-difference和inserter"><a href="#set-difference和inserter" class="headerlink" title="set_difference和inserter"></a>set_difference和inserter</h2><p><code>1、set_difference</code>是C++中的一个函数，它接受两个有序的范围作为输入，并输出在第一个范围中但不在第二个范围中的元素。输出写入到一个第三个范围中，该范围必须足够大以容纳所有输出的元素。</p><p>也就是求出集合A和集合B中，只在集合A中而不在集合B中的元素</p><p>使用之前需要排序</p><p>2、inserter(container,pos)：返回通用插入型迭代器，内部会调用容器container的insert(pos)方法将数据插入到pos位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3; </span><br><span class="line">    <span class="comment">// 相当于把在v1而不再v2的元素插入到v3后面 </span></span><br><span class="line">    std::<span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(v3,v3.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="comment">// 输出 3，4，5 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:v3) &#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove算法用于从容器中移除特定值的元素</p><p>但是，需要注意的是 <code>std::remove</code> 并不真正地从容器中删除元素，而是将所有不等于给定值的元素移动到容器的前面，并返回一个迭代器，指向新逻辑末尾之后的位置。</p><p>如果真的想要减少容器的大小并释放不再使用的内存，通常还需要结合容器的 <code>erase</code> 成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// 想要移除的值</span></span><br><span class="line">    <span class="type">int</span> value_to_remove = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 将所有不等于value_to_remove的元素移动到前面</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), value_to_remove);</span><br><span class="line">    <span class="comment">// 输出 1,3,4,5,6,2,5,6</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_end指向的是“新逻辑末尾”的下一个位置</span></span><br><span class="line">    <span class="comment">// 删除所有value_to_remove</span></span><br><span class="line">    v.<span class="built_in">erase</span>(new_end, v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 1,3,4,5,6</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Base</title>
      <link href="/2024/05/09/C++/C++Base/"/>
      <url>/2024/05/09/C++/C++Base/</url>
      
        <content type="html"><![CDATA[<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><h2 id="模版是什么"><a href="#模版是什么" class="headerlink" title="模版是什么"></a>模版是什么</h2><p>模版是一种使用“数据类型”作为参数来产生一系列函数或类的机制。它使类中某些数据成员或成员函数的参数、返回值能取得不同的类型。</p><p>模版分为函数模版和类模版</p><h2 id="为什么需要模版"><a href="#为什么需要模版" class="headerlink" title="为什么需要模版"></a>为什么需要模版</h2><p>程序设计中会出现这样的问题：两个或者多个函数，其程序部分除了参数类型不同外，其余部分完全相同。如此需要编写多个重载函数。增加代码量。</p><h2 id="模版函数和模版类"><a href="#模版函数和模版类" class="headerlink" title="模版函数和模版类"></a>模版函数和模版类</h2><p>在声明一个函数模版后，编译系统发现有一个对应的函数调用时，将根据实参中的数据类型来确认是否与函数模版中对应的形参想匹配，然后生成一个重载函数。该重载函数定义体与函数模版的函数定义体相同，只是数据类型参数具体化了。</p><p>模版函数：函数模版的数据类型参数被具体化了，称为模版函数</p><p>模版类：在声明一个类模版后，可以创建该类模版的实例，称为模版类</p><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>函数模版：是对一批模样相同的函数的说明，是对这部分函数集合的公共描述，它不是某一个具体的函数，是带有“类型参数”的一种描述。</p><p>模版函数：是将函数模版内的“数据类型参数”取某一个具体的数据类型后得到的具体重载函数。</p><p>函数模版是抽象的，模版函数是具体的。</p><h3 id="函数模版的定义"><a href="#函数模版的定义" class="headerlink" title="函数模版的定义"></a>函数模版的定义</h3><ul><li>语法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> 模版类型形参表&gt;</span><br><span class="line">返回值类型 函数名(模版函数形参表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数定义体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，模版类型形参表中的类型可以是任意类型，每一个类型参数前都需要加前缀class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">GetMax</span><span class="params">(Type a, Type b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成模版函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetMax</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、函数模版的声明和定义必须是全局作用域；</p><p>2、函数模版不能被声明为类的成员函数；</p><p>3、虽然模版参数T可以实例化成各种类型，但是采用同一模版参数T的各参数之间必须保持完全一致的类型。因为模版类型参数不具有隐式类型转换的能力。</p><ul><li>重载函数模版</li></ul><p>函数模版可以重载。重载函数和函数模版同时存在时，编译时的函数匹配规则如下：</p><p>1、利用重载函数来寻找完全匹配重载函数，如没有转入2</p><p>2、利用函数模版来寻找完全匹配项，如没有则报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">GetMax</span><span class="params">(Type a, Type b)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;TemplateGetMax&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">GetMax</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DoubleGetMax&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 匹配函数模版</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">GetMax</span>(<span class="number">1</span>, <span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 匹配重载函数</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">GetMax</span>(<span class="number">1.0</span>, <span class="number">2.0</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">TemplateGetMax</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">DoubleGetMax</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>只有重载函数时，参数可以进行隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">GetMax</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DoubleGetMax&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 参数隐式类型转换</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">GetMax</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">DoubleGetMax</span></span><br><span class="line"><span class="comment">97</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>类模版与函数模版类似，它可以为各种不同的数据类型定义一种模版，在引用时使用不同的数据类型实例化该类模版，以生成具体的模版类，而模版类则可以用于生成具体的对象。所以类模版描述了代码相似的部分类的集合。</p><h3 id="类模版的定义"><a href="#类模版的定义" class="headerlink" title="类模版的定义"></a>类模版的定义</h3><ul><li>语法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> 类型形参表&gt;</span><br><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line">    <span class="comment">// 类声明体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> 类型形参表&gt;</span><br><span class="line">返回值类型 类名&lt;类型名表&gt;::成员函数名<span class="number">1</span>(形参表)&#123;</span><br><span class="line">    <span class="comment">// 成员函数1定义体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> 类型形参表&gt;</span><br><span class="line">返回值类型 类名&lt;类型名表&gt;::成员函数名<span class="number">2</span>(形参表)&#123;</span><br><span class="line">    <span class="comment">// 成员函数2定义体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> 类型形参表&gt;</span><br><span class="line">返回值类型 类名&lt;类型名表&gt;::成员函数名<span class="built_in">n</span>(形参表)&#123;</span><br><span class="line">    <span class="comment">// 成员函数n定义体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，类型形参表与函数模版中类型形参表的意义一样；类型形参表也可以包含表达式参数，例如<code>template&lt;class T1, class T2, int exp1&gt;</code>；类型名表是类型形参的使用。</p><ul><li>生成具体对象语法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模版名&lt;类型实参表&gt; 对象名(值实参表)</span><br></pre></td></tr></table></figure><ul><li>代码示例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TNumber</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TNumber</span>(Type);</span><br><span class="line">    ~<span class="built_in">TNumber</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetItem</span><span class="params">(Type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetItem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type m_item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">TNumber&lt;Type&gt;::<span class="built_in">TNumber</span>(Type item) &#123;</span><br><span class="line">    m_item = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> TNumber&lt;Type&gt;::<span class="built_in">SetItem</span>(Type item) &#123;</span><br><span class="line">    m_item = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Type TNumber&lt;Type&gt;::<span class="built_in">GetItem</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> m_item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">TNumber&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;obj1.<span class="built_in">GetItem</span>()&lt;&lt;endl;</span><br><span class="line">    obj1.<span class="built_in">SetItem</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;obj1.<span class="built_in">GetItem</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">TNumber&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">10.01</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;obj2.<span class="built_in">GetItem</span>()&lt;&lt;endl;</span><br><span class="line">    obj2.<span class="built_in">SetItem</span>(<span class="number">20.01</span>);</span><br><span class="line">    cout&lt;&lt;obj2.<span class="built_in">GetItem</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">10.01</span></span><br><span class="line"><span class="comment">20.01</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="类模版继承"><a href="#类模版继承" class="headerlink" title="类模版继承"></a>类模版继承</h3><p>继承方式有以下两种：</p><p>1、从类模版直接派生出新的类模版</p><p>2、用类模版生成的模版类派生出新类</p><ul><li>从类模版直接派生出新的类模版</li></ul><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类类模版定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类模版定义派生类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSet</span> : <span class="keyword">public</span> TList&lt;Type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类类模版定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类类模版定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类模版定义派生类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSet</span> : <span class="keyword">public</span> TList&lt;Type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类类模版定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(Type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> TSet&lt;Type&gt;::<span class="built_in">SetData</span>(Type data) &#123;</span><br><span class="line">    m_data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Type TSet&lt;Type&gt;::<span class="built_in">GetData</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TSet&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">SetData</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;obj.<span class="built_in">GetData</span>()&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从类模版生成的模版类派生出新类</li></ul><p>这种方式较少使用</p><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类类模版定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类模版定义派生类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSet</span> : <span class="keyword">public</span> TList&lt;实参类型&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类类模版定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类类模版定义</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类模版定义派生类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSet</span> : <span class="keyword">public</span> TList&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类类模版定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(Type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> TSet&lt;Type&gt;::<span class="built_in">SetData</span>(Type data) &#123;</span><br><span class="line">    m_data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Type TSet&lt;Type&gt;::<span class="built_in">GetData</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TSet&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">SetData</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;obj.<span class="built_in">GetData</span>()&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="什么是异常处理"><a href="#什么是异常处理" class="headerlink" title="什么是异常处理"></a>什么是异常处理</h2><p>在 C++ 中，程序的异常处理是一种非常重要的机制，能够帮助程序员更好地处理运行时产生的错误。异常处理机制是将程序中可能出现的错误情况进行抛出、捕获、处理等操作，从而能够让程序更具有健壮性。</p><h2 id="为什么需要异常处理"><a href="#为什么需要异常处理" class="headerlink" title="为什么需要异常处理"></a>为什么需要异常处理</h2><p>能够让程序更具有健壮性和稳定性</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>当程序运行到了某一处不可处理的错误状态时，不仅仅只停留在出错的地方，而是通过抛出（throwing）一条表达式来引发（raised）一个异常，从而让其他能够处理这种错误的代码来处理这个错误状态。C++ 中使用 <code>throw</code> 来抛出异常，其具体语法与使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">exception_type</span>();</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、当执行一个throw时，跟在throw后面的语句将不再被执行；程序的控制权从throw转移到与之匹配的catch模块</p><p>2、栈展开</p><p>如果对抛出异常的函数的调用语句位于一个try语句块内，则检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。否则，如果该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果仍然没有找到匹配的catch，则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="comment">// throw 100;</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception &amp;e) <span class="comment">// 没有被捕获</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">int</span> &amp;e) <span class="comment">// 捕获</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl; <span class="comment">// 输出200</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行</p><p>4、当找不到匹配的catch时，程序将调用标准库函数terminate，顾名思义，terminate负责终止程序的执行过程。</p><p>5、如果抛出异常发生在构造函数中，则当前的对象可能只构造了一部分；如果抛出异常发生在析构函数，会导致有些资源未被正确释放内存。</p><p>因为throw后的代码不执行，所以尽量不要在构造函数和析构函数中抛出异常。</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>C++ 中的异常处理机制使用 <code>try...catch</code> 结构来捕获异常。其中，<code>try</code> 代码块是用来包裹可能抛出异常的代码块。当这个代码块中的代码抛出了异常，其对应的 <code>catch</code> 代码块就会被执行。<code>catch</code> 所引用的异常类型必须与 <code>throw</code> 所抛出的异常类型一致，才能正确捕获并处理异常。</p><h3 id="catch形参引用与非引用"><a href="#catch形参引用与非引用" class="headerlink" title="catch形参引用与非引用"></a>catch形参引用与非引用</h3><p>如果catch的参数是基类类型，可以使用其派生类类型的异常对象对其进行初始化。此时，如果catch的参数是非引用类型，则异常对象将被切掉一部分（只能使用基类的），这与将派生类对象以值传递的方式传给一个普通函数差不多；另一种情况，如果catch的参数是基类的引用，则该参数将以常规方式绑定到异常对象上（基类和子类都能用，一般是继承自库中异常类，使用多态的形式）。</p><h3 id="最佳catch匹配"><a href="#最佳catch匹配" class="headerlink" title="最佳catch匹配"></a>最佳catch匹配</h3><p>如果在多个catch语句的类型之间存在着继承关系，则应该把继承链最底端的类（子类）放在前面，而将继承链最顶端的类（基类 ）放在后面。因为catch是按照顺序匹配的，如果基类在前，也可能匹配上，但可能不是最佳的匹配</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>有时候，一个单独的catch语句不能完整地处理某个异常。这种情况可以进行重新抛出，使用<code>throw;</code>后面不接任何表达式（从而让此catch外的catch捕获）。空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内</p><p>如果在外面使用<code>throw;</code>则会调用terminate终止程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseException</span> : <span class="keyword">public</span> std::exception &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BaseException caught&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedException</span> : <span class="keyword">public</span> BaseException &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DerivedException caught&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// 假设这里抛出了DerivedException异常  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DerivedException</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> BaseException&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 会被捕获，由于多态性，e.what()输出DerivedException caught</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an exception of type BaseException or derived: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 重新抛出异常，以便它可以被更外层的catch块捕获  </span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 注意这里没有参数  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="built_in">handleException</span>(); <span class="comment">// 调用可能抛出异常的函数  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> DerivedException&amp; e) &#123;</span><br><span class="line">        <span class="comment">// throw;重新抛出DerivedException();所以此时catch匹配，e.what()输出DerivedException caught</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specifically caught a DerivedException: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">        <span class="comment">// 在这里可以针对DerivedException做特殊处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught a general exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">        <span class="comment">// 在这里可以处理所有其他类型的std::exception异常  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an unknown exception&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">        <span class="comment">// 在这里可以处理所有未知类型的异常  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Caught an exception of type BaseException or derived: DerivedException caught</span></span><br><span class="line"><span class="comment">Specifically caught a DerivedException: DerivedException caught</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h3><p>为了一次性捕获所有异常，使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码，形如<code>catch(...)</code>。一条捕获所有异常的语句可以与任意类型的异常匹配。</p><p>注意：如果<code>catch(...)</code>与其他几个catch语句一起出现，则catch(…)必须在最后的位置。出现在捕获所有异常语句后面的catch语句将永远不会被匹配。</p><h3 id="函数try语句块与构造函数"><a href="#函数try语句块与构造函数" class="headerlink" title="函数try语句块与构造函数"></a>函数try语句块与构造函数</h3><p>处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块</p><p>函数try语句块使得一组catch语句既能处理构造函数体发生的异常，也能处理构造函数的初始化列表发生的异常</p><p>注意：在初始化构造函数的参数时（值拷贝可能发生其他的构造函数调用）也可能发生异常，这样的异常不属于函数try语句块的一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line">    <span class="type">int</span>* ptr;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) <span class="keyword">try</span> : <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123; <span class="comment">// 成员初始化列表，无法直接加catch  </span></span><br><span class="line">        <span class="comment">// 如果new失败，会抛出std::bad_alloc异常  </span></span><br><span class="line">        <span class="comment">// 但是这个异常会在外围的try块中捕获  </span></span><br><span class="line">        <span class="comment">// 这里是构造函数的函数体开始  </span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;  </span><br><span class="line">        <span class="comment">// 捕获在构造函数体内部抛出的异常  </span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught bad_alloc in constructor body: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">        <span class="comment">// 在这里你可以选择抛出另一个异常，或者进行其他处理  </span></span><br><span class="line">        <span class="comment">// 但如果构造函数中发生了未处理的异常，对象将不会被构造，且析构函数不会被调用  </span></span><br><span class="line">        <span class="comment">// throw; // 重新抛出异常  </span></span><br><span class="line">    &#125; </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  </span><br><span class="line">        <span class="keyword">delete</span>[] ptr; <span class="comment">// 析构函数也可能抛出异常（比如delete失败，但很少见）  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">1000000000000</span>)</span></span>; <span class="comment">// 尝试分配大量内存，可能失败  </span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;  </span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught bad_alloc in main: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Caught bad_alloc in constructor body: std::bad_array_new_length</span></span><br><span class="line"><span class="comment">Caught bad_alloc in main: std::bad_array_new_length</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a>noexcept异常说明</h3><ul><li>概念</li></ul><p>noexcept异常说明指定某个函数不会抛出异常</p><p>noexcept可以用于函数、函数指针、成员函数。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的&#x3D;0之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;haha&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*ptr)() <span class="keyword">noexcept</span> = f;  </span><br><span class="line">    <span class="built_in">ptr</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：编译器不会验证异常说明，也就是说即使声明了异常说明，而函数体内抛出了异常，编译器并不会报错。这种情况会终止程序。</p><p>优点：对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。</p><ul><li>异常说明实参</li></ul><p>noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参是true，则函数不会抛出异常；如果实参是false，则函数可能抛出异常</p><p>noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为noexcept异常说明的bool实参出现时，它是一个运算符。</p><p><code>void f() noexcept(noexcept(g()))</code>如果函数g承诺了不会抛出异常，则f也不会抛出异常；如果g没有异常说明符，或者g虽然有异常说明符但是允许抛出异常，则f也可能抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常说明与指针、虚函数和拷贝控制"><a href="#异常说明与指针、虚函数和拷贝控制" class="headerlink" title="异常说明与指针、虚函数和拷贝控制"></a>异常说明与指针、虚函数和拷贝控制</h3><p>指针：如果为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以</p><p>虚函数：如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常</p><p>拷贝控制类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Son::test</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Son test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*ptr)() <span class="keyword">noexcept</span> = f;</span><br><span class="line">    ptr = f;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    Son son = <span class="built_in">Son</span>();</span><br><span class="line">    Base&amp; obj = son;</span><br><span class="line">    obj.<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常类体系与自定义异常"><a href="#异常类体系与自定义异常" class="headerlink" title="异常类体系与自定义异常"></a>异常类体系与自定义异常</h3><p><img src="data:image/png;base64,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" alt="img"></p><p>类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。其中what函数返回一个const char＊，该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。</p><p>类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。在这些类中，what负责返回用于初始化异常对象的信息。因为what是虚函数，所以当我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本（自定义异常）。</p><p>自定义异常示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>: <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span>(MyException&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyException caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span>(exception&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Other exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">MyException caught: C++ Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用异常处理机制时需要注意以下几点：</p><ol><li>尽量避免过多的使用异常处理，因为异常处理会对程序的性能产生一定的影响，尤其是对于实时性要求比较高的程序。</li><li>应该尽量使用内置的异常类型，不要过多自定义异常类型，以减少学习和维护成本。</li><li>在抛出异常时，应该准确、明确地指定异常类型，以便在异常处理模块中能够准确处理。</li><li>应该尽可能将异常处理写在合适的位置，以最大程度地保证程序的健壮性和稳定性。</li></ol><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="什么是命名空间"><a href="#什么是命名空间" class="headerlink" title="什么是命名空间"></a>什么是命名空间</h2><p>命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p><h2 id="为什么需要命名空间"><a href="#为什么需要命名空间" class="headerlink" title="为什么需要命名空间"></a>为什么需要命名空间</h2><p>解决名称冲突。命名空间是一种将代码包含在逻辑分组内的方式，来防止不同代码区域的名称之间的冲突。C++ 标准库定义了大量的名称，而我们在写程序时也使用了大量的名称，有些时候可能会产生命名冲突的问题，这就需要命名空间来解决。</p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> name &#123;</span><br><span class="line">    <span class="comment">// 命名空间作用域 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，name是自己定义的命名空间名字。只要能出现在全局作用域中的声明就能放在命名空间作用域内</p><p>注意：</p><p>1、命名空间的名字也必须在定义它的作用域内保持唯一</p><p>2、命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p><p>3、命名空间作用域后面无须分号。</p><h3 id="每个命名空间都是一个作用域"><a href="#每个命名空间都是一个作用域" class="headerlink" title="每个命名空间都是一个作用域"></a>每个命名空间都是一个作用域</h3><p>命名空间中的每个名字都必须表示该空间内的唯一实体</p><p>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。</p><p>位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间（使用命名空间加双冒号形式）</p><h3 id="命名空间可以是不连续的"><a href="#命名空间可以是不连续的" class="headerlink" title="命名空间可以是不连续的"></a>命名空间可以是不连续的</h3><p>如果定义一个名为nsp的命名空间。</p><p>则可能是定义了一个名为nsp的新命名空间，也可能是为已经存在的命名空间添加一些新成员。如果之前没有名为nsp的命名空间定义，则创建一个新的命名空间；否则，打开已经存在的命名空间定义并为其添加一些新成员的声明。</p><p>利用该特性，可以将几个独立的接口和实现文件组成一个命名空间（声明放在头文件，实现放在源文件）</p><p>1、命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。</p><p>2、命名空间成员的定义部分则置于另外的源文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">namespace</span> cplusplus</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;factory.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cplusplus::MyClass obj;</span><br><span class="line">    std::cout&lt;&lt; obj.x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员</p><h3 id="定义命名空间成员"><a href="#定义命名空间成员" class="headerlink" title="定义命名空间成员"></a>定义命名空间成员</h3><p>在命名空间内，可以不加命名空间名的前缀，而直接写成员名</p><p>在命名空间外，需要加上命名空间名的前缀，标识该成员所属的命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(MyClass&amp; obj)</span></span>; <span class="comment">// MyClass无需加上前缀cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cplusplus</span>::MyClass&#123; <span class="comment">// 命名空间外定义需要加上前缀</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cplusplus::test</span><span class="params">(cplusplus::MyClass&amp; obj)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;obj.x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cplusplus::MyClass obj;</span><br><span class="line">    cplusplus::<span class="built_in">test</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版特例化"><a href="#模版特例化" class="headerlink" title="模版特例化"></a>模版特例化</h3><p>模板特例化必须定义在原始模板所属的命名空间中。和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">cplusplus</span>::MyClass&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cplusplus::MyClass&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">    std::cout&lt;&lt;obj.x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h3><p>全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间（globalnamespace）中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中（如全局变量、全局函数、全局类）。</p><p>作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字。下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::member_name</span><br></pre></td></tr></table></figure><p>表示全局命名空间中的一个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;::x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>嵌套的命名空间是指定义在其他命名空间中的命名空间</p><p>内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="keyword">namespace</span> cplusplus1 &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> cplusplus2 &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = cplusplus1::x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;cplusplus::x&lt;&lt;std::endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h3><p>和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline，也可以不写。</p><h3 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h3><p>未命名的命名空间（unnamed namespace）是指关键字namespace后紧跟花括号括起来的一系列声明语句</p><p>说明：类似静态特性</p><p>1、未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。</p><p>2、一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。</p><p>3、和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。</p><p>4、未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别（不然就有名字冲突）</p><p>5、定义在未命名的命名空间中的名字可以直接使用</p><p>6、一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl; <span class="comment">// 1</span></span><br><span class="line">    std::cout&lt;&lt;cplusplus::x&lt;&lt;std::endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未命名的命名空间取代文件中的静态声明"><a href="#未命名的命名空间取代文件中的静态声明" class="headerlink" title="未命名的命名空间取代文件中的静态声明"></a>未命名的命名空间取代文件中的静态声明</h3><p>在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在其所在的文件外不可见。</p><p>在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。</p><h2 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h2><p>可以使用<code>namespace_name::member_name</code>的形式访问命名空间成员，但是这种使用方式比较繁琐</p><p>接下来介绍几种其他方式</p><h3 id="命名空间别名"><a href="#命名空间别名" class="headerlink" title="命名空间别名"></a>命名空间别名</h3><p>命名空间的别名（namespace alias）使得我们可以为命名空间的名字设定一个短得多的同义词</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> aliasName = namespace_name;</span><br></pre></td></tr></table></figure><p>其中，aliasName就是namespace_name的别名</p><p>说明：</p><p>1、不能在命名空间还没有定义前就声明别名，否则将产生错误。</p><p>2、一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p><p>3、命名空间的别名也可以指向一个嵌套的命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">namespace</span> cplusplus2 &#123;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名空间别名</span></span><br><span class="line"><span class="keyword">namespace</span> cplus = cplusplus;</span><br><span class="line"><span class="keyword">namespace</span> cplus2 = cplusplus::cplusplus2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;cplus::x&lt;&lt;std::endl; <span class="comment">// 1</span></span><br><span class="line">    std::cout&lt;&lt;cplus2::y&lt;&lt;std::endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h3><ul><li>说明</li></ul><p>一条using声明（using declaration）语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p><ul><li>作用域范围</li></ul><p>从using声明的地方开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字只能在using声明所在的作用域以及其内层作用域中使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 该x只在main作用域有效</span></span><br><span class="line">    <span class="keyword">using</span> cplusplus::x; <span class="comment">// 使用using声明命名空间成员，隐藏了外层作用域的x</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl; <span class="comment">// 输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>using声明出现的位置</li></ul><p>一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员（子类会隐藏父类的相同成员，一般在子类中使用using声明该基类成员）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Base::foo()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">using</span> Base::foo; <span class="comment">// 引入Base类的foo函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Derived foo(int)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125; <span class="comment">// 派生类自己的foo函数，隐藏了Base的foo  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Derived d;  </span><br><span class="line">    d.<span class="built_in">foo</span>(); <span class="comment">// 如果没有使用using Base::foo，则是错误：调用不明确，因为有两个foo  </span></span><br><span class="line">    d.<span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// 调用Derived的foo(int)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果在Derived中使用了using Base::foo;  </span></span><br><span class="line">    <span class="comment">// 则d.foo(); 调用的是Base的foo  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using指示"><a href="#using指示" class="headerlink" title="using指示"></a>using指示</h3><p>using指示在所在的作用域内，命名空间中所有的成员都可以直接访问，而不需要加上命名空间前缀来区别</p><ul><li>语法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cplusplus; <span class="comment">// using指示</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x不用添加命名空间前缀</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl; <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用域范围</li></ul><p>using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了</p><p>由于using指示引用命名空间中所有的名称，所以该作用域有同名的名称造成冲突</p><ul><li>using指示出现的位置</li></ul><p>在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">16</span>, j = <span class="number">15</span>, k = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 正确：cplusplus的j隐藏在命名空间中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// using指示，cplusplus中的名字被添加到当前作用域</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> cplusplus;</span><br><span class="line">    ++i; <span class="comment">// cplusplus中的i设置为17</span></span><br><span class="line">    <span class="comment">// ++j; // 二义性错误：是全局的j还是cplusplus::j?</span></span><br><span class="line">    ++::j; <span class="comment">// 正确：将全局的j设定为1</span></span><br><span class="line">    ++cplusplus::j; <span class="comment">// 正确，将cplusplus::j设定为16</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">97</span>; <span class="comment">// 当前局部的k隐藏了cplusplus::k</span></span><br><span class="line">    ++k; <span class="comment">// 将当前局部的k设定为98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意</li></ul><p>1、不要在头文件中使用using指示或者using声明，这会导致包含了该头文件的其他文件，在使用名称时容易造成名称冲突，所以建议在源文件中使用using指示或者声明</p><p>2、最好不要使用using指示，因为这会引用到该命名空间所有的名称，容易造成冲突。可以用于文件自身使用了using指示的文件中。这样比较好控制名称冲突。</p><h2 id="类、命名空间与作用域"><a href="#类、命名空间与作用域" class="headerlink" title="类、命名空间与作用域"></a>类、命名空间与作用域</h2><p>对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止</p><p>对于位于命名空间中的类来说，常规的查找规则仍然适用：当成员函数使用某个名字时，首先在该成员中进行查找，然后在类中查找（包括基类），接着在外层作用域中查找，这时一个或几个外层作用域可能就是命名空间</p><p>限定符<code>A::C1::f3</code>指出了查找类作用域和命名空间作用域的相反次序。首先查找函数f3的作用域，然后查找外层类C1的作用域，最后检查命名空间A的作用域以及包含着f3定义的作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">C1</span>(): <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">j</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 正确，初始化C1::i和C1::j</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> k; &#125; <span class="comment">// 返回A::k</span></span><br><span class="line">            <span class="comment">// int f2() &#123; return h; &#125; // 错误，h未定义</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> h = i; <span class="comment">// 用A::i进行初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::C1::<span class="built_in">f3</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 正确，返回A::h</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实参相关的查找与类类型形参"><a href="#实参相关的查找与类类型形参" class="headerlink" title="实参相关的查找与类类型形参"></a>实参相关的查找与类类型形参</h3><p>当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 常规输入s</span></span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="comment">// 使用operator&gt;&gt;函数没有加上命名空间前缀</span></span><br><span class="line">    <span class="comment">// 这是因为还会检查实参的作用域，类对象s的命名空间是std，而operator&gt;&gt;在其中定义</span></span><br><span class="line">    <span class="keyword">operator</span>&gt;&gt;(std::cin, s);</span><br><span class="line">    std::cout&lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元声明与实参相关的查找"><a href="#友元声明与实参相关的查找" class="headerlink" title="友元声明与实参相关的查找"></a>友元声明与实参相关的查找</h3><ul><li>友元的使用</li></ul><p>友元声明并不会自动改变友元函数或类的可见性（或作用域）</p><p>当一个类或函数被声明为另一个类的友元时，它获得了访问该类的私有和保护成员的权限。但这种访问权限是单向的，并且不改变友元本身的可见性或作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h  </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> privateMember;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">privateMember</span>(value) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 声明 friendFunction 为友元函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(MyClass&amp; obj)</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：这里并没有定义 friendFunction，只是声明了它作为友元  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// MyClass.cpp  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在这里定义 friendFunction  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 由于是友元，可以访问 MyClass 的私有成员  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyClass&#x27;s privateMember: &quot;</span> &lt;&lt; obj.privateMember &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// main.cpp  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 因为 friendFunction 在 MyClass.cpp 中定义了，并且被包含在项目中，  </span></span><br><span class="line">    <span class="comment">// 所以这里可以调用它  </span></span><br><span class="line">    <span class="built_in">friendFunction</span>(obj);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元和命名空间</li></ul><p>在C++中，当一个类或函数首次在友元声明中出现时，并且之前没有在该作用域或任何包含作用域中声明过，编译器会假设这个名称是指向最近的外层命名空间的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;f2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;f&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A::C&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    A::C cobj;</span><br><span class="line">    <span class="built_in">f</span>(cobj); <span class="comment">// 调用的全局定义域的f，输出f1</span></span><br><span class="line">    <span class="comment">// 想要调用到命名空间中的f，需要将全局作用域定义的f注释掉</span></span><br><span class="line">    <span class="comment">// 因为只有f是首次声明为友元，才是属于命名空间的</span></span><br><span class="line">    <span class="comment">// f2(); // 错误，找不到f2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoBase</title>
      <link href="/2024/04/20/Go/GoBase/"/>
      <url>/2024/04/20/Go/GoBase/</url>
      
        <content type="html"><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是数据地址的名字，变量可以在程序中修改其值。用于数据变化</p><p>变量名不能包含空格，不能使用关键字（如if），</p><p>分为全局变量和局部变量</p><p>默认值：</p><ul><li>整型：0</li><li>浮点型：0.0</li><li>布尔：false</li><li>字符串：空字符串</li><li>指针型：nil</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>变量有其生效的区域，这个区域，我们称之为<code>作用域</code>。</p><ul><li>函数内部声明的变量，为<code>局部变量</code>，作用域仅限于函数内部</li><li>函数外部声明的变量，为<code>全局变量</code>，作用域在当前包有效，如果首字母大写，在所有包有效</li><li><code>&#123;&#125;</code>包括的区域，称之为代码块，如果变量定义在<code>&#123;&#125;</code>内部，只在代码块内有效</li></ul><h3 id="声明定义变量"><a href="#声明定义变量" class="headerlink" title="声明定义变量"></a>声明定义变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种：指定变量类型，声明后若不赋值，使用默认值</span></span><br><span class="line">    <span class="comment">//int 的默认值是0</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二种：根据值自行判定变量类型(类型推导)</span></span><br><span class="line">    <span class="keyword">var</span> b= <span class="number">10.11</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三种：省略var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误</span></span><br><span class="line">    <span class="comment">//下面的方式等价var num string name = &quot;tom&quot;</span></span><br><span class="line">    <span class="comment">//:=的:不能省略，否则错误</span></span><br><span class="line">    c := <span class="string">&quot;tom&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量定义变量"><a href="#批量定义变量" class="headerlink" title="批量定义变量"></a>批量定义变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一次性声明多个变量</span></span><br><span class="line">    <span class="keyword">var</span> n1, n2, n3 <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1, <span class="string">&quot;n2=&quot;</span>, n2, <span class="string">&quot;n3=&quot;</span>, n3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一次性声明多个变量的方式2</span></span><br><span class="line">    <span class="keyword">var</span> t1, t2, t3 = <span class="number">100</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;t1=&quot;</span>, t1, <span class="string">&quot;t2=&quot;</span>, t2, <span class="string">&quot;t3=&quot;</span>, t3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一次性声明多个变量的方式3，同样可以使用类型推导</span></span><br><span class="line">    f1, f2, f3 := <span class="number">100</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;f1=&quot;</span>, f1, <span class="string">&quot;f2=&quot;</span>, f2, <span class="string">&quot;f3=&quot;</span>, f3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>定义成大写，可被其他文件调用。</p><p>全局变量的生命周期跟随程序的生命周期</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> h3 = <span class="string">&quot;jack&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的声明方式，也可以改成一次性声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        n3 = <span class="number">300</span></span><br><span class="line">        n4 = <span class="number">900</span></span><br><span class="line">        n5 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;h1=&quot;</span>, h1, <span class="string">&quot;h2=&quot;</span>, h2, <span class="string">&quot;h3=&quot;</span>, h3)</span><br><span class="line">    fmt.Println(<span class="string">&quot;n3=&quot;</span>, n3, <span class="string">&quot;n4=&quot;</span>, n4, <span class="string">&quot;n5=&quot;</span>, n5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量不能在整个程序生命周期内不能被修改</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>(1)常量使用const关键字</p><p>(2)常量在定义的时候，必须初始化</p><p>(3)常量不能修改</p><p>(4)常量只能修饰bool、数值类型(int、float系列)、string类型</p><p>(5)语法：const identifier [type] &#x3D;value</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在golang中并没有枚举这种类型，但在go中有类似的方式，就是使用<code>iota</code>常量生成器。从定义开始，iota值从0加1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iota从定义开始，每行开始自增1</span></span><br><span class="line"><span class="comment">// 当遇到新的赋值后，例如d和f，后续没有重新赋值iota，那么后续常量还是之前的赋值，如e和g</span></span><br><span class="line"><span class="comment">// 又赋值为iota后，看自增到多少，如h和i</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a = <span class="literal">iota</span></span><br><span class="line">   b        </span><br><span class="line">   c = <span class="literal">iota</span>+<span class="number">2</span>     </span><br><span class="line">   d = <span class="string">&quot;hi&quot;</span> </span><br><span class="line">   e      </span><br><span class="line">   f = <span class="number">100</span>  </span><br><span class="line">   g        </span><br><span class="line">   h, i = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(a, b, c, d, e, f, g, h, i)</span><br><span class="line">   <span class="comment">// 输出: 0 1 4 hi hi 100 100 8 7</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> name=<span class="string">&quot;tom&quot;</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> tax <span class="type">float64</span>=<span class="number">0.8</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> a <span class="type">int</span> <span class="comment">//error,没有初始化值</span></span><br><span class="line">    <span class="keyword">const</span> b=<span class="number">9</span>/<span class="number">3</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> c = getVal() <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>值类型：基本数据类型（int系列，float系列，bool等），字符串，数组，结构体</p><p>引用类型：切片，map，channel，interface</p><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p><table><thead><tr><th>类型</th><th>长度(字节)</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>FALSE</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的 uint32 或 uint64 整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li>有符号整型</li></ul><p>分类：int、int8、int16、int32、int64</p><p>数据范围：<code>-2^(n-1) 到 2^(n-1)-1</code></p><p>正数使用原码表示，最高位为0，故int8的正数取值范围为0到2^(7)-1（0000 0000 ~ 0111 1111）</p><p>负数使用补码表示，最高位为1，故int8的负数取值范围为-2^(7)到-1（1000 0000 ~ 1111 1111）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>=<span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int8</span>=<span class="number">2</span></span><br><span class="line">   <span class="comment">// 其他int16,int32，int64类推</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查看某个变量的数据类型</span></span><br><span class="line">   <span class="comment">//查看某个变量的占用字节大小</span></span><br><span class="line">   <span class="comment">// 输出：b的类型int8 b占用的字节数是1</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b的类型%T b占用的字节数是%d\n&quot;</span>, b, unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无符号整型</li></ul><p>uint、uint8、uint16、uint32、uint64、uintptr</p><p>无符号整型范围: <code> 0 到 2^n-1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">uint</span>=<span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">uint8</span>=<span class="number">2</span></span><br><span class="line">   <span class="comment">// 其他uint16,uint32，uint64类推</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查看某个变量的数据类型</span></span><br><span class="line">   <span class="comment">//查看某个变量的占用字节大小</span></span><br><span class="line">   <span class="comment">// 输出：b的类型uint8 b占用的字节数是1</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b的类型%T b占用的字节数是%d\n&quot;</span>, b, unsafe.Sizeof(b))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// uintptr用法</span></span><br><span class="line">   <span class="comment">// 无符号的整型 uintptr，是用于存放指针的，它没有指定具体的 bit 大小但是足以容纳指针</span></span><br><span class="line">   <span class="comment">// uintptr的值表示了内存中的一个地址位置，它是一个整数，用于存储和计算指针的数值，但并不直接引用任何对象</span></span><br><span class="line">   <span class="comment">// 定义一个 int 变量</span></span><br><span class="line">   x := <span class="number">42</span></span><br><span class="line">   <span class="comment">// 获取 x 的地址，并转换为 uintptr</span></span><br><span class="line">   ptrUint := <span class="type">uintptr</span>(unsafe.Pointer(&amp;x))</span><br><span class="line">   <span class="comment">// 将 uintptr 转换回 *int 指针</span></span><br><span class="line">   ptrInt := (*<span class="type">int</span>)(unsafe.Pointer(ptrUint))</span><br><span class="line">   <span class="comment">// 通过转换后的指针修改 x 的值</span></span><br><span class="line">   *ptrInt = <span class="number">1337</span></span><br><span class="line">   <span class="comment">// 输出修改后的 x 值</span></span><br><span class="line">   fmt.Println(x) <span class="comment">// 输出: 1337</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。</p><p>这两种浮点型数据格式遵循<code>IEEE 754</code>标准</p><p><code>float32</code> 的浮点数的最大范围约为<code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p><p><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">float32</span>  = <span class="number">5.21</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">13.14</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a,<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出：c=0.123</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">float64</span> = <span class="number">.123</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 科学计数法表示</span></span><br><span class="line">   d := <span class="number">5.1234e2</span></span><br><span class="line">   e := <span class="number">5.1234e-2</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;d=&quot;</span>,d,<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line">   <span class="comment">//输出：d= 512.34 e= 0.051234</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex64`和`complex128</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">complex64</span> = <span class="number">5</span> + <span class="number">21i</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">complex128</span> = <span class="number">13</span> + <span class="number">14i</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a,<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算复数的实部和虚部</span></span><br><span class="line">   realPart := <span class="built_in">real</span>(a)</span><br><span class="line">   imagPart := <span class="built_in">imag</span>(a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;realPart=&quot;</span>,realPart,<span class="string">&quot;imagPart=&quot;</span>,imagPart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔型数据只有true和false，且不能参与任何计算以及类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">bool</span>= <span class="literal">false</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">   <span class="comment">//注意事项</span></span><br><span class="line">   <span class="comment">//1、bool类型占用存储空间是1个字节</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a的占用空间=&quot;</span>, unsafe.Sizeof(a))</span><br><span class="line">   <span class="comment">//2、bool类型只能取true或者false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>组成每个字符串的元素叫做字符，可以通过遍历或者单个获取字符串元素获得字符。 字符用<code>单引号&#39; &#39;</code>包裹起来</p><p>字符有两种类型</p><ul><li>byte：也是uint8类型，表示 ASCII 码的一个字符。</li><li>rune：也是int32类型，代表一个 Unicode 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="comment">// 输出对应的码值 a= 97</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   <span class="comment">// 输出对应的字符，a=a</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a=%c\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用rune表示中文，byte一个字节存不下</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">rune</span> = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%c\n&quot;</span>,b)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 字符类型实际上存储的实对应码值，所以可以用整型存储</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c=%c c对应的码值=%d\n&quot;</span>, c, c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>特性：一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列</li><li>字符串转义符：</li></ul><table><thead><tr><th>转义</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠自身</td></tr></tbody></table><ul><li>多行字符串</li></ul><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code> &#96;&#96;字符</p><p>特点：反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><ul><li>修改字符串</li></ul><p>要修改字符串，需要先将其转换成<code>[]rune或[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基本用法</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;我爱\ngo&quot;</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多行字符串</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">string</span> =<span class="string">`</span></span><br><span class="line"><span class="string">      我爱go\n</span></span><br><span class="line"><span class="string">      hello world</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="comment">// 分行时需要将+保留在上一行</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">string</span> = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span> +</span><br><span class="line">      <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line">    <span class="comment">// c[0] = &#x27;c&#x27; // 错误，这里不能修改字符串的内容，go中的字符串是不可变的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改字符串</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    ans := []<span class="type">byte</span>(str)</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(ans)) <span class="comment">// 输出：Hello</span></span><br><span class="line">    </span><br><span class="line">    str = <span class="string">&quot;码斋&quot;</span></span><br><span class="line">    res := []<span class="type">rune</span>(str)</span><br><span class="line">    res[<span class="number">1</span>] = <span class="string">&#x27;神&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(res)) <span class="comment">// 输出：码神</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>作用：指向其他变量，用于操作该变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       &amp;是取地址操作符</span></span><br><span class="line"><span class="comment">       *是取值操作符</span></span><br><span class="line"><span class="comment">       *数据类型是指针类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">521</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// 输出： a=521</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 基本用法，指向变量a</span></span><br><span class="line">   <span class="keyword">var</span> p *<span class="type">int</span> = &amp;a</span><br><span class="line">   <span class="comment">// 修改后，变量a的值会发生变化</span></span><br><span class="line">   *p = <span class="number">1314</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">//输出：a=1314</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">   <span class="comment">// *ptr = 10 // 错误，此时ptr是一个空指向，没有一个可用的内存地址供其操作</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用new函数提前在内存中申请一块内存，这样就获得了一个内存地址，就不会报错了</span></span><br><span class="line">   ptr = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   *ptr = <span class="number">10</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;ptr=&quot;</span>, *ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>特点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 数组：是同一种数据类型的固定长度的序列。</span><br><span class="line">数组声明：<span class="keyword">var</span> 数组变量名 [元素数量]Type</span><br><span class="line"><span class="number">2.</span> 数组定义：<span class="keyword">var</span> a [<span class="built_in">len</span>]<span class="type">int</span>，比如：<span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span>，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。</span><br><span class="line"><span class="number">3.</span> 长度是数组类型的一部分，因此，<span class="keyword">var</span> a[<span class="number">5</span>] <span class="type">int</span>和<span class="keyword">var</span> a[<span class="number">10</span>]<span class="type">int</span>是不同的类型。</span><br><span class="line"><span class="number">4.</span> 数组可以通过下标进行访问，下标是从<span class="number">0</span>开始，最后一个元素下标是：<span class="built_in">len</span><span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span> 访问越界，如果下标在数组合法范围之外，则触发访问越界，会<span class="built_in">panic</span></span><br><span class="line"><span class="number">6.</span> 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。</span><br><span class="line"><span class="number">7.</span>支持 <span class="string">&quot;==&quot;</span>、<span class="string">&quot;!=&quot;</span> 操作符，因为内存总是被初始化过的。</span><br><span class="line"><span class="number">8.</span>指针数组 [n]*T，数组指针 *[n]T。（指针数组：数组存储的是指针，是一个数组。数组指针：指针指向数组）</span><br></pre></td></tr></table></figure><ul><li>赋值初始化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 方式一</span></span><br><span class="line">   <span class="comment">// 未赋值的元素有默认值</span></span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   fmt.Println(a) <span class="comment">// 1 2 3 0 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式二</span></span><br><span class="line">   <span class="keyword">var</span> b = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   fmt.Println(b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式三，元素个数推导</span></span><br><span class="line">   <span class="keyword">var</span> c = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">   <span class="keyword">var</span> d = [...]<span class="type">string</span>&#123;<span class="number">2</span>:<span class="string">&quot;嘿嘿&quot;</span>,<span class="number">3</span>:<span class="string">&quot;嘻嘻&quot;</span>&#125; <span class="comment">// 使用索引号初始化元素。</span></span><br><span class="line">   fmt.Println(d)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式四，类型推导</span></span><br><span class="line">   e := [...]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;哈哈&quot;</span>,<span class="number">2</span>:<span class="string">&quot;嘿嘿&quot;</span>,<span class="number">3</span>:<span class="string">&quot;嘻嘻&quot;</span>&#125;</span><br><span class="line">   fmt.Println(e)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>取值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   <span class="comment">// 索引方式</span></span><br><span class="line">   fmt.Println(a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历方式</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">      fmt.Println(a[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// for-range</span></span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;i=&quot;</span>, i, <span class="string">&quot;v=&quot;</span>, v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二维数组</li></ul><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用方式：先声明/定义再赋值</span><br><span class="line">语法：var 数组名 [大小][大小]类型</span><br><span class="line">使用方式2：直接初始化</span><br><span class="line">1、声明：var 数组名 [大小][大小]类型 = [大小][大小]类型&#123;&#123;初值...&#125;,&#123;初值...&#125;&#125;</span><br><span class="line">2、赋值(有默认值，比如int类型 就是0)</span><br><span class="line">3、说明：二维数组在声明/定义时也对应有四种写法[和一维数组类似]</span><br><span class="line">var 数组名 [大小][大小]类型=[大小][大小]类型&#123;&#123;初值...&#125;,&#123;初值...&#125;&#125;</span><br><span class="line">var 数组名 [大小][大小]类型=[...][大小]类型&#123;&#123;初值...&#125;,&#123;初值...&#125;&#125;</span><br><span class="line">var 数组名=[大小][大小]类型&#123;&#123;初值...&#125;,&#123;初值...&#125;&#125;</span><br><span class="line">var 数组名=[...][大小]类型&#123;&#123;初值...&#125;,&#123;初值...&#125;&#125;</span><br></pre></td></tr></table></figure><p>二维数组初始化和遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 初始化，可以省略行的大小，通过总元素和列数进行推导</span></span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> = [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">   <span class="keyword">var</span> b [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> = [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">   <span class="keyword">var</span> c = [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">   d := [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;b=&quot;</span>, b, <span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d)</span><br><span class="line">   <span class="comment">// 遍历</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(a[i]); j++ &#123;</span><br><span class="line">         fmt.Println(a[i][j])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// for-range遍历，外层相当于拿到了一维数组，再对一维数组进行for-range，进行取值</span></span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">      <span class="keyword">for</span> _, value := <span class="keyword">range</span> v &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul><li>介绍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">切片的基本介绍</span><br><span class="line"><span class="number">1</span> 切片的英文是slice</span><br><span class="line"><span class="number">2</span> 切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制</span><br><span class="line"><span class="number">3</span> 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度<span class="built_in">len</span>(slice)都一样</span><br><span class="line"><span class="number">4</span> 切片的长度是可以变化的，因此切片是一个可以动态变化数组</span><br><span class="line"><span class="number">5</span> 切片定义的基本语法</span><br><span class="line"> <span class="keyword">var</span> 切片名 []类型</span><br><span class="line"> <span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">切片内存分布</span><br><span class="line"><span class="number">1</span>、slice的确是一个引用类型</span><br><span class="line"><span class="number">2</span>、slice从底层来说，其实就是一个数据结构（<span class="keyword">struct</span>结构）</span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">        ptr *[<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">        <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">        <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">结构体内部的指针指向数组，切片的改变会引起数组的改变。并通过<span class="built_in">cap</span>进行动态扩容。</span><br></pre></td></tr></table></figure><ul><li>定义和使用</li></ul><p>方式一：直接引用其他数组</p><p>方式二：使用make分配内存</p><p>方式三：直接初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义的切片如果没有初始化，是不可以直接操作的</span></span><br><span class="line">   <span class="comment">// 方式一：引用其他数据</span></span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   <span class="comment">//声明/定义一个切片</span></span><br><span class="line">   <span class="comment">//slice就是切片名</span></span><br><span class="line">   <span class="comment">//a[1:3]表示slice引用到a这个数组</span></span><br><span class="line">   <span class="comment">//引用a数组的起始下标为1，最后的下标为3（但是不包含3）</span></span><br><span class="line">   slice := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice的元素是=&quot;</span>, slice)       <span class="comment">// 2,3</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice的元素个数=&quot;</span>, <span class="built_in">len</span>(slice)) <span class="comment">// 求长度 // 输出：2</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice的容量是=&quot;</span>, <span class="built_in">cap</span>(slice))  <span class="comment">//求容量，切片的容量是可以动态变化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式二：通过make来创建切片。</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      基本语法：</span></span><br><span class="line"><span class="comment">      var 切片名 []type = make([]type,len,[cap])</span></span><br><span class="line"><span class="comment">      参数说明：type：就是数据类型；len：大小；cap：指定切片容量，可选</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">var</span> slice2 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">   slice2[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   slice2[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">   slice2 = <span class="built_in">append</span>(slice2, <span class="number">2</span>)</span><br><span class="line">   fmt.Println(slice2) <span class="comment">// 1 2 0 0 0 2</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      总结：</span></span><br><span class="line"><span class="comment">      1、通过make方式创建切片可以指定切片的大小和容量，容量如果不设置，那么容量等于切片大小</span></span><br><span class="line"><span class="comment">      2、如果没有给切片的各个元素赋值，那么就会使用默认值</span></span><br><span class="line"><span class="comment">      3、通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   方式1和方式2的区别</span></span><br><span class="line"><span class="comment">   方式1是直接引用数组，这个数组是事先存在的，程序员是可见的</span></span><br><span class="line"><span class="comment">   方式2是通过make来创建切片，make也会创建一个数组，是由切片在底层进行维护，程序员是看不见的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式三：直接初始化</span></span><br><span class="line">   <span class="keyword">var</span> arr []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   fmt.Println(arr) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="comment">// 方式一：普通for循环</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">      fmt.Println(arr[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式二：for-range</span></span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;i=&quot;</span>, i, <span class="string">&quot;v=&quot;</span>, v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常见方法</li></ul><p>增加元素：append(splice, element)</p><p>拷贝元素：copy(newSplice, oldSplice)</p><p>删除元素：间接删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、切片初始化时，var slice = arr[startIndex:endIndex]</span></span><br><span class="line"><span class="comment">说明：从arr数组下标为startIndex，取到下标为endIndex的元素（不含arr[endIndex]）</span></span><br><span class="line"><span class="comment">2、切片初始化时，仍然不能越界，范围在[0-len(arr)]之间，但是可以动态增长</span></span><br><span class="line"><span class="comment">(1)var slice = arr[0:end] 可以简写var slice = arr[:end]</span></span><br><span class="line"><span class="comment">(2)var slice = arr[start:len(arr)] 可以简写var slice = arr[start:]</span></span><br><span class="line"><span class="comment">(3)var slice = arr[0:len(arr)] 可以简写var slice = arr[:]</span></span><br><span class="line"><span class="comment">3、cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素</span></span><br><span class="line"><span class="comment">4、切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片来使用</span></span><br><span class="line"><span class="comment">5、切片可以继续切片</span></span><br><span class="line"><span class="comment">6、用append内置函数，可以对切片进行动态追加</span></span><br><span class="line"><span class="comment">切片append操作的底层原理分析</span></span><br><span class="line"><span class="comment">(1)切片append操作的本质就是对数组扩容</span></span><br><span class="line"><span class="comment">(2)go底层会创建一个新的数组newArr(安装扩容后大小)</span></span><br><span class="line"><span class="comment">(3)将slice原来包含的元素拷贝到新的数组newArr</span></span><br><span class="line"><span class="comment">(4)slice重新引用到newArr</span></span><br><span class="line"><span class="comment">(5)注意newArr是在底层来维护的，程序员不可见</span></span><br><span class="line"><span class="comment">7、切片的拷贝操作</span></span><br><span class="line"><span class="comment">切片使用copy内置函数完成拷贝</span></span><br><span class="line"><span class="comment">说明：copy(para1,para2) para1和para2都是切片类型</span></span><br><span class="line"><span class="comment">8、切片是引用类型，所以在传递时，遵守引用传递机制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//5</span></span><br><span class="line">   <span class="keyword">var</span> slice []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">   slice2 := slice[:]</span><br><span class="line">   slice2[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice2=&quot;</span>, slice2) <span class="comment">// 1 0 0 0 0</span></span><br><span class="line">   <span class="comment">//切片是引用类型，改变元素的值，同时也会改变引用的值</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=&quot;</span>, slice) <span class="comment">// 1 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// append 使用</span></span><br><span class="line">   <span class="keyword">var</span> slice3 []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   slice3 = <span class="built_in">append</span>(slice3, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">   <span class="comment">//通过append将切片slice3追加给slice3，注意后面需要...</span></span><br><span class="line">   slice3 = <span class="built_in">append</span>(slice3, slice3...)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice3&quot;</span>, slice3) <span class="comment">// 1 2 3 4 5 6 1 2 3 4 5 6</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy 使用</span></span><br><span class="line">   <span class="keyword">var</span> slice4 []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> slice5 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="built_in">copy</span>(slice5, slice4)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice4=&quot;</span>, slice4) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">   <span class="comment">//slice4和slice5的数据空间是独立的</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice5=&quot;</span>, slice5) <span class="comment">// 1 2 3 4 5 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 间接删除</span></span><br><span class="line">   <span class="keyword">var</span> slice6 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   slice6 = <span class="built_in">append</span>(slice6[:<span class="number">2</span>], slice6[<span class="number">3</span>:]...)</span><br><span class="line">   fmt.Println(slice6) <span class="comment">// 1 2 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>排序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort.Slice(s1, func(i, j int) bool &#123; return s1[i] &lt; s1[j] &#125;)</span></span><br><span class="line"><span class="comment">sort.Slice(s2, func(i, j int) bool &#123; return s2[i] &lt; s2[j] &#125;)</span></span><br><span class="line"><span class="comment">可以使用以上方法对切片快速进行排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;</span><br><span class="line">   sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[i] &gt; arr[j]</span><br><span class="line">   &#125;)</span><br><span class="line">   fmt.Println(arr) <span class="comment">// 5 4 3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>string和slice</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、string底层是一个byte数组，因此string也可以进行切片处理</span></span><br><span class="line"><span class="comment">2、string和切片在内存的形式，string也代表一个地址</span></span><br><span class="line"><span class="comment">3、string是不可变的，也就是说不能通过str[0]=&#x27;z&#x27;方式来修改字符串</span></span><br><span class="line"><span class="comment">4、如果需要修改字符串，可以先将string-&gt;[]byte 或者 []rune -&gt; 修改 -&gt; 重写转成string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s1, s2 := []byte(s), []byte(t)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 转为切片</span></span><br><span class="line">   str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">   slice := str[<span class="number">2</span>:]</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=&quot;</span>, slice) <span class="comment">// llo </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 字符串不可变性</span></span><br><span class="line">   <span class="comment">//str[0]=&#x27;z&#x27;//编译不通过，报错，原因是string是不可变的</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转为[]byte</span></span><br><span class="line">   arr1 := []<span class="type">byte</span>(str)</span><br><span class="line">   arr1[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">   str = <span class="type">string</span>(arr1)</span><br><span class="line">   fmt.Println(<span class="string">&quot;str=&quot;</span>, str) <span class="comment">// zello</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//细节，我们转成[]byte后，可以处理英文和数字，但是不能处理中文</span></span><br><span class="line">   <span class="comment">//原因是[]byte字节来处理，而一个汉字，是3个字节，因此就会乱码</span></span><br><span class="line">   <span class="comment">//解决方法是将string转成[]rune即可，因为[]rune是按字符处理，兼容汉字</span></span><br><span class="line">   arr2 := []<span class="type">rune</span>(str)</span><br><span class="line">   arr2[<span class="number">0</span>] = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">   str = <span class="type">string</span>(arr2)</span><br><span class="line">   fmt.Println(<span class="string">&quot;str=&quot;</span>, str) <span class="comment">// 北ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>冒号使用</li></ul><p>a[x:y:z]的含义：</p><p>切片内容： [x:y] </p><p>切片长度：y-x </p><p>切片容量：z-x</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;</span><br><span class="line">   data := arr[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">   fmt.Println(<span class="string">&quot;len=&quot;</span>, <span class="built_in">len</span>(data)) <span class="comment">// 2</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;cap=&quot;</span>, <span class="built_in">cap</span>(data)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">   data = arr[<span class="number">2</span>:<span class="number">5</span>:<span class="number">5</span>]</span><br><span class="line">   fmt.Println(<span class="string">&quot;len=&quot;</span>, <span class="built_in">len</span>(data)) <span class="comment">// 3</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;cap=&quot;</span>, <span class="built_in">cap</span>(data)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>[][]T</li></ul><p>[][]T，是指元素类型为 []T 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   data := [][]<span class="type">int</span>&#123;</span><br><span class="line">      []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">      []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">      []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(data)</span><br><span class="line">   fmt.Println(data[<span class="number">1</span>]) <span class="comment">// 4 5</span></span><br><span class="line">   fmt.Println(data[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>介绍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">map</span>介绍</span><br><span class="line"><span class="keyword">map</span>是key-value数据结构，又称为字段或者关联数组。类似其它编程语言的集合，在编程中是经常使用到的</span><br><span class="line"><span class="number">2</span>、<span class="keyword">map</span>声明</span><br><span class="line">基本语法：</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">map</span>变量名 <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line">(<span class="number">1</span>)key可以是什么类型</span><br><span class="line"><span class="keyword">go</span>中的<span class="keyword">map</span>，key可以是很多种类型，比如<span class="type">bool</span>，数字，<span class="type">string</span>，指针，channel，还可以是只包含前面几个类型的接口，结构体，数组</span><br><span class="line">通常为<span class="type">int</span>、<span class="type">string</span></span><br><span class="line">注意：slice、<span class="keyword">map</span>还有function不可以，因为这几个没法用==来判断</span><br><span class="line">(<span class="number">2</span>)valuetype可以是什么类型</span><br><span class="line">valuetype的类型和key基本一样</span><br><span class="line">通常为数字(整数，浮点数)，<span class="type">string</span>，<span class="keyword">map</span>，<span class="keyword">struct</span></span><br><span class="line">注意：声明是不会分配内存的，初始化需要<span class="built_in">make</span>，分配内存后才能赋值和使用</span><br><span class="line"><span class="number">3</span>、<span class="keyword">map</span>是引用类型，遵守引用类型传递的机制，在一个函数接收<span class="keyword">map</span>，修改后，会直接修改原来的<span class="keyword">map</span></span><br><span class="line"><span class="number">4</span>、<span class="keyword">map</span>的容量达到后，再想<span class="keyword">map</span>增加元素，会自动扩容，并不会发生<span class="built_in">panic</span>，也就是说<span class="keyword">map</span>能动态增长 键值对(key-value)</span><br></pre></td></tr></table></figure><ul><li>声明定义</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">make(map[KeyType]ValueType, [cap])</span><br><span class="line"></span><br><span class="line">其中cap表示map的容量，该参数虽然不是必须的，但是应该在初始化map的时候就为其指定一个合适的容量。</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">map的使用方式</span><br><span class="line">(1)方式1</span><br><span class="line">var a map[string]string</span><br><span class="line">a=make(map[string]string,10)</span><br><span class="line">(2)方式2</span><br><span class="line">var a = make(map[string]string)</span><br><span class="line">(3)方式3</span><br><span class="line">var a map[string]string = map[string]string&#123;</span><br><span class="line">   &quot;no4&quot;:&quot;武汉&quot;,</span><br><span class="line">&#125;</span><br><span class="line">a[&quot;no1&quot;]=&quot;湖北&quot;</span><br><span class="line">*/</span><br><span class="line">func main() &#123;</span><br><span class="line">   //方式1</span><br><span class="line">   var a map[string]string</span><br><span class="line">   a = make(map[string]string, 10)</span><br><span class="line">   a[&quot;name&quot;] = &quot;liu&quot;</span><br><span class="line">   fmt.Println(a)</span><br><span class="line"></span><br><span class="line">   //方式2</span><br><span class="line">   b := make(map[string]string)</span><br><span class="line">   b[&quot;location&quot;] = &quot;武汉&quot;</span><br><span class="line">   fmt.Println(b)</span><br><span class="line"></span><br><span class="line">   //方式3</span><br><span class="line">   var heroes map[string]string = map[string]string&#123;</span><br><span class="line">      &quot;hero&quot;: &quot;zhu&quot;,</span><br><span class="line">   &#125;</span><br><span class="line">   heroes[&quot;name&quot;] = &quot;feng&quot;</span><br><span class="line">   fmt.Println(&quot;heroes=&quot;, heroes)</span><br><span class="line"></span><br><span class="line">   //案例</span><br><span class="line">   /*</span><br><span class="line">      演示一个key-value的value是map的案例</span><br><span class="line">      比如：要存放3个学生信息，每个学生有name和sex信息</span><br><span class="line">      思路：map[string]map[string]string</span><br><span class="line">   */</span><br><span class="line">   studentMap := make(map[string]map[string]string)</span><br><span class="line">   studentMap[&quot;stu01&quot;] = make(map[string]string, 3) //这句话不能少</span><br><span class="line">   studentMap[&quot;stu01&quot;][&quot;name&quot;] = &quot;哈哈&quot;</span><br><span class="line">   studentMap[&quot;stu01&quot;][&quot;sex&quot;] = &quot;男&quot;</span><br><span class="line">   studentMap[&quot;stu01&quot;][&quot;address&quot;] = &quot;武汉&quot;</span><br><span class="line"></span><br><span class="line">   studentMap[&quot;stu02&quot;] = make(map[string]string, 3) //这句话不能少</span><br><span class="line">   studentMap[&quot;stu02&quot;][&quot;name&quot;] = &quot;嘿嘿&quot;</span><br><span class="line">   studentMap[&quot;stu02&quot;][&quot;sex&quot;] = &quot;女&quot;</span><br><span class="line">   studentMap[&quot;stu02&quot;][&quot;address&quot;] = &quot;武汉&quot;</span><br><span class="line">   fmt.Println(studentMap)</span><br><span class="line">   fmt.Println(studentMap[&quot;stu02&quot;])</span><br><span class="line">   fmt.Println(studentMap[&quot;stu02&quot;][&quot;address&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><p>for-range</p><p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map的遍历使用for-range的结构遍历</span></span><br><span class="line"><span class="comment">//map的长度可以用len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   a[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;武汉&quot;</span></span><br><span class="line">   a[<span class="string">&quot;no2&quot;</span>] = <span class="string">&quot;湖北&quot;</span></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;k=%v v=%v\n&quot;</span>, k, v)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;a有&quot;</span>, <span class="built_in">len</span>(a), <span class="string">&quot;对key-value&quot;</span>) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用for-range遍历一个结构比较复杂的map</span></span><br><span class="line">   studentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   studentMap[<span class="string">&quot;stu01&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>) <span class="comment">//这句话不能少</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;男&quot;</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;武汉&quot;</span></span><br><span class="line"></span><br><span class="line">   studentMap[<span class="string">&quot;stu02&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>) <span class="comment">//这句话不能少</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu02&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;嘿嘿&quot;</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu02&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;女&quot;</span></span><br><span class="line">   studentMap[<span class="string">&quot;stu02&quot;</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;武汉&quot;</span></span><br><span class="line">   <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> studentMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;k1=&quot;</span>, k1)</span><br><span class="line">      <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;\t k2=%v v2=%v\n&quot;</span>, k2, v2)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增删改查</li></ul><p>增改：map[“key”]&#x3D;value，不存在key，就是增；存在key，就是改</p><p>删：delete(map,”key”)，删除key</p><p>查：value,ok&#x3D;map[“key”]，ok为true，则查到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、map增加和更新</span></span><br><span class="line"><span class="comment">map[&quot;key&quot;]=value //如果key还没有，就是增加，如果key存在就是修改</span></span><br><span class="line"><span class="comment">2、map删除</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">delete(map,&quot;key&quot;)，delete是一个内置函数，如果key存在，就删除该key-value，如果key不存在，不操作，但是也不会报错</span></span><br><span class="line"><span class="comment">细节说明：</span></span><br><span class="line"><span class="comment">(1)如果要删除map的所有key，没有一个专门的方法一次性删除，可以遍历一下key，逐个删除</span></span><br><span class="line"><span class="comment">(2)或者map = make(...)，make一个新的，让原来的成为垃圾，被gc回收</span></span><br><span class="line"><span class="comment">3、map查找</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   a[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;武汉&quot;</span></span><br><span class="line">   a[<span class="string">&quot;no2&quot;</span>] = <span class="string">&quot;湖北&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//删除</span></span><br><span class="line">   <span class="built_in">delete</span>(a, <span class="string">&quot;no1&quot;</span>)</span><br><span class="line">   <span class="built_in">delete</span>(a, <span class="string">&quot;no4&quot;</span>) <span class="comment">//不报错</span></span><br><span class="line">   fmt.Println(a) <span class="comment">// no2:湖北</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//全部删除</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   fmt.Println(a) <span class="comment">// 空[]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//map查找</span></span><br><span class="line">   b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   b[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;猪猪&quot;</span></span><br><span class="line">   val, ok := b[<span class="string">&quot;no1&quot;</span>]</span><br><span class="line">   fmt.Println(ok) <span class="comment">//true</span></span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;有no1，key值为%v\n&quot;</span>, val) <span class="comment">// 执行</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;没有no1 key\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切片map</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本介绍：</span></span><br><span class="line"><span class="comment">切片的数据类型如果是map，则称为slice of map切片，这样使用则map个数就可以动态变化了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//1、声明一个map切片</span></span><br><span class="line">   <span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">   monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>) <span class="comment">//准备放入两个妖怪</span></span><br><span class="line">   <span class="comment">//2、增加一个妖怪的信息</span></span><br><span class="line">   <span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">      monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">      monsters[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">      monsters[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;500&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(monsters)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里需要使用到切片的append函数，可以动态的增加monster</span></span><br><span class="line">   <span class="comment">//1、先定义个monster信息</span></span><br><span class="line">   newMonster := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;火云邪神&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:  <span class="string">&quot;200&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   monsters = <span class="built_in">append</span>(monsters, newMonster)</span><br><span class="line">   fmt.Println(monsters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map值切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本介绍：</span></span><br><span class="line"><span class="comment">map的值是切片，值可以动态变化了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">   fmt.Println(sliceMap)</span><br><span class="line">   fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">   key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">   value, ok := sliceMap[key]</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      value = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">   sliceMap[key] = value</span><br><span class="line">   fmt.Println(sliceMap) <span class="comment">// 中国:[北京,上海]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>排序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本介绍：</span></span><br><span class="line"><span class="comment">(1)go中没有一个专门的方法针对map的key进行排序</span></span><br><span class="line"><span class="comment">(2)go中的map默认是无序的，注意也不是按照添加的顺序存放的，每次遍历，得到的输出可能不一样</span></span><br><span class="line"><span class="comment">(3)go中map的排序，是先将key进行排序，然后根据key值遍历输出即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">   map1[<span class="number">10</span>] = <span class="number">100</span></span><br><span class="line">   map1[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">   map1[<span class="number">4</span>] = <span class="number">56</span></span><br><span class="line">   map1[<span class="number">8</span>] = <span class="number">90</span></span><br><span class="line">   fmt.Println(map1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果按照map的key的顺序进行排序输出</span></span><br><span class="line">   <span class="comment">//1、先将map的key放入到切片中</span></span><br><span class="line">   <span class="comment">//2、对切片排序</span></span><br><span class="line">   <span class="comment">//3、遍历切片，然后按照key来输出map的值</span></span><br><span class="line">   <span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line">   <span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//排序</span></span><br><span class="line">   sort.Ints(keys) <span class="comment">//递增排序</span></span><br><span class="line">   fmt.Println(keys)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;map1[%v]=%v\n&quot;</span>, k, map1[k])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">   map[1:13 4:56 8:90 10:100]</span></span><br><span class="line"><span class="comment">   [1 4 8 10]</span></span><br><span class="line"><span class="comment">   map1[1]=13</span></span><br><span class="line"><span class="comment">   map1[4]=56</span></span><br><span class="line"><span class="comment">   map1[8]=90</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用</p><p>强制类型转换的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><h3 id="基本类型相互转换"><a href="#基本类型相互转换" class="headerlink" title="基本类型相互转换"></a>基本类型相互转换</h3><p>都使用强制类型转换</p><p>只有相同底层类型的变量之间可以进行相互转换，不同底层类型的变量相互转换时会引发编译错误（如bool转int）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 基本用法</span></span><br><span class="line">   <span class="comment">// 被转换的是变量存储的数据，变量本身的数据类型并没有改变。比如a的类型还是int32</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float32</span> = <span class="type">float32</span>(a)</span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int8</span> = <span class="type">int8</span>(a)</span><br><span class="line">   <span class="keyword">var</span> d <span class="type">int64</span> = <span class="type">int64</span>(a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a=%v b=%v c=%v d=%v\n&quot;</span>, a, b, c, d)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 高精度向低精度转换会损失精度</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line">   <span class="keyword">var</span> f <span class="type">int8</span> = <span class="type">int8</span>(e)</span><br><span class="line">   fmt.Println(<span class="string">&quot;f=&quot;</span>, f) <span class="comment">// 输出f=63</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本类型转换string"><a href="#基本类型转换string" class="headerlink" title="基本类型转换string"></a>基本类型转换string</h3><ul><li>方式一：<code>fmt.Sprintf</code></li><li>方式二：strconv包下的函数<code>strconv.Formatxxx</code></li><li>方式三：strconv包中的函数Itoa</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">5.21</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">byte</span> = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式一</span></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%v\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, b)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%v\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>, c)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>, d)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式二</span></span><br><span class="line">   str = strconv.FormatInt(<span class="type">int64</span>(a), <span class="number">10</span>) <span class="comment">// 10表示10进制</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 说明: &#x27;f&#x27;格式  10：表示小数位保留10位 64：表示这个小数是float64</span></span><br><span class="line">   str = strconv.FormatFloat(b, <span class="string">&#x27;f&#x27;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = strconv.FormatBool(c)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式三</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int64</span> = <span class="number">1314</span></span><br><span class="line">   str = strconv.Itoa(<span class="type">int</span>(e))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string转换基本类型"><a href="#string转换基本类型" class="headerlink" title="string转换基本类型"></a>string转换基本类型</h3><p>使用strconv.Parsexxx函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;1314&quot;</span></span><br><span class="line">   <span class="comment">// 转int</span></span><br><span class="line">   <span class="comment">// 只想获取到value int，不想获取err，所以使用_忽略</span></span><br><span class="line">   a, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 10是十进制，64返回的是int64</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a type %T=%v\n&quot;</span>, a, a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转float</span></span><br><span class="line">   str = <span class="string">&quot;13.14&quot;</span></span><br><span class="line">   b, _ := strconv.ParseFloat(str, <span class="number">64</span>) <span class="comment">// 64返回的是float64</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b type %T=%v\n&quot;</span>, b, b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转bool</span></span><br><span class="line">   str = <span class="string">&quot;true&quot;</span></span><br><span class="line">   c, _ := strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;c type %T=%v\n&quot;</span>, c, c)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当string不能转换为相应的基本数据类型时，会有默认值</span></span><br><span class="line">   str = <span class="string">&quot;1234&quot;</span></span><br><span class="line">   d, _ := strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;d type %T=%v\n&quot;</span>, d, d) <span class="comment">// 输出： d type bool=false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>用于数据类型之间的运算操作</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p> 注：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 加法</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">   num := a + b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 减法</span></span><br><span class="line">   num = a - b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 乘法</span></span><br><span class="line">   num = a * b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 除法</span></span><br><span class="line">   <span class="comment">// 如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分</span></span><br><span class="line">   fmt.Println(<span class="number">10</span>/<span class="number">4</span>) <span class="comment">// 输出：2</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">float32</span> = <span class="number">10</span>/<span class="number">4</span></span><br><span class="line">   fmt.Println(c) <span class="comment">// 输出：2</span></span><br><span class="line">   <span class="comment">// 希望保留小数部分，则需要有浮点数参与运算</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">float32</span> = <span class="number">10.0</span> / <span class="number">4</span></span><br><span class="line">   fmt.Println(d)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 模运算</span></span><br><span class="line">   <span class="comment">// 公式：a%b = a - a / b * b</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;10%3=&quot;</span>, <span class="number">10</span>%<span class="number">3</span>) <span class="comment">// 输出 1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;-10%3=&quot;</span>, <span class="number">-10</span>%<span class="number">3</span>) <span class="comment">// 输出 -1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;10%-3=&quot;</span>, <span class="number">10</span>%<span class="number">-3</span>) <span class="comment">// 输出 1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;-10%-3&quot;</span>, <span class="number">-10</span>%<span class="number">-3</span>) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ++和--使用</span></span><br><span class="line">   <span class="comment">// 只有后++，后--</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   e++</span><br><span class="line">   fmt.Println(<span class="string">&quot;e=&quot;</span>, e) <span class="comment">// 输出 11</span></span><br><span class="line">   e--</span><br><span class="line">   fmt.Println(<span class="string">&quot;e=&quot;</span>, e) <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>判断两个变量的大小关系</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">9</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">8</span></span><br><span class="line">   fmt.Println(a == b) <span class="comment">// false</span></span><br><span class="line">   fmt.Println(a != b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &gt; b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &gt;= b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &lt; b) <span class="comment">// false</span></span><br><span class="line">   fmt.Println(a &lt;= b) <span class="comment">// false</span></span><br><span class="line">   flag := a &gt; b</span><br><span class="line">   fmt.Println(<span class="string">&quot;flag=&quot;</span>, flag) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用于两个变量或表达式的逻辑关系</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td>ll</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;test...&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">27</span></span><br><span class="line">   <span class="comment">// 逻辑与</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &amp;&amp; a &lt; <span class="number">30</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 逻辑或</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> || a &lt; <span class="number">30</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok2&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 逻辑非</span></span><br><span class="line">   <span class="keyword">if</span> !(a &lt; <span class="number">18</span>) &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok3&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 短路与</span></span><br><span class="line">   <span class="comment">// 因为a&lt;18为false，因此后面的test()就不执行</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; <span class="number">18</span> &amp;&amp; test() &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;短路与&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 短路或</span></span><br><span class="line">   <span class="comment">// 因为a&gt;18为true，因此后面的test()就不执行</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> || test() &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;短路或&quot;</span>) <span class="comment">//执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>将一个变量赋值给另一个变量</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>l&#x3D;</td><td>按位或后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 赋值</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>  = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 复合赋值，其余复合赋值运算符类似</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   a += b</span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 交换两个数</span></span><br><span class="line">   <span class="comment">// 方式1</span></span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">int</span> = <span class="number">2</span></span><br><span class="line">   temp = c</span><br><span class="line">   c = d</span><br><span class="line">   d = temp</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=2,d=1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//方式2</span></span><br><span class="line">   c = c+d</span><br><span class="line">   d = c-d</span><br><span class="line">   c = c-d</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=1,d=2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式3</span></span><br><span class="line">   c, d = d, c</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=2,d=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>二进制：01组成</p><p>八进制：0-7，满8进1，以数字0开头表示</p><p>十六进制：0-9及A-F，满16进1，以0x或0X开头表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">        <span class="comment">//二进制输出，直接输出是十进制</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//八进制：0-7，满8进1，以数字0开头表示</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="type">int</span> = <span class="number">011</span> <span class="comment">//011=8+1=9</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0-9及A-F，满16进1，以0x或0X开头表示</span></span><br><span class="line">        <span class="keyword">var</span> k <span class="type">int</span> = <span class="number">0x11</span> <span class="comment">//0x11=16+1=17</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;k=&quot;</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td>l</td><td>参与运算的两数各对应的二进位相或。（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 0001</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">3</span> <span class="comment">// 0011</span></span><br><span class="line">   <span class="comment">// 与</span></span><br><span class="line">   fmt.Println(a&amp;b) <span class="comment">// 1</span></span><br><span class="line">   <span class="comment">// 或</span></span><br><span class="line">   fmt.Println(a|b) <span class="comment">// 3</span></span><br><span class="line">   <span class="comment">// 异或</span></span><br><span class="line">   fmt.Println(a^b) <span class="comment">// 2</span></span><br><span class="line">   <span class="comment">//左移</span></span><br><span class="line">   fmt.Println(a&lt;&lt;b) <span class="comment">// 8</span></span><br><span class="line">   <span class="comment">//右移</span></span><br><span class="line">   fmt.Println(a&gt;&gt;b) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>go没有三元运算符</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//传统的三元运算</span></span><br><span class="line">   <span class="comment">//n=i&gt;j?i:j</span></span><br><span class="line">   <span class="comment">//在golang中是没有这个传统三元运算的</span></span><br><span class="line">   <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="type">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">      n = i</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      n = j</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量输入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">   <span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line">   <span class="keyword">var</span> sal <span class="type">float32</span></span><br><span class="line">   <span class="keyword">var</span> isPass <span class="type">bool</span></span><br><span class="line">   <span class="comment">// 方式1 fmt.Scanln</span></span><br><span class="line">   <span class="comment">// 当程序执行到fmt.Scanln(&amp;name)，程序会停止在这里，等待用户输入，并回车</span></span><br><span class="line">   fmt.Scanln(&amp;name)</span><br><span class="line">   fmt.Scanln(&amp;age)</span><br><span class="line">   fmt.Scanln(&amp;sal)</span><br><span class="line">   fmt.Scanln(&amp;isPass)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;名字是%v\n 年龄是%v\n 薪水是%v\n 是否通过考试%v\n&quot;</span>, name, age, sal, isPass)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式2 fmt.Scanf，可以按指定的格式输入</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入你的姓名，年龄，薪水，是否通过考试，使用空格隔开&quot;</span>)</span><br><span class="line">   fmt.Scanf(<span class="string">&quot;%s %d %f %t&quot;</span>, &amp;name, &amp;age, &amp;sal, &amp;isPass)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;名字是%v\n 年龄是%v\n 薪水是%v\n 是否通过考试%v\n&quot;</span>, name, age, sal, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件语句if"><a href="#条件语句if" class="headerlink" title="条件语句if"></a>条件语句if</h3><p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。</p><ul><li>单分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">18</span></span><br><span class="line">   <span class="comment">// 单分支</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;a不大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在go中，支持在if中直接定义一个变量</span></span><br><span class="line">   <span class="keyword">if</span> b := <span class="number">20</span>; b &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;b大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="comment">//else的位置只能这样，不能换行</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;大于18...&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="comment">//多分支判断</span></span><br><span class="line">   <span class="keyword">if</span> a == <span class="number">100</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">80</span> &amp;&amp; score == <span class="number">99</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;呵呵&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt;= <span class="number">80</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嘿嘿&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嗯嗯&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> a &lt;= <span class="number">8</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">      <span class="keyword">if</span> b == <span class="number">10</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;嗯嗯&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嘿嘿&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件语句switch"><a href="#条件语句switch" class="headerlink" title="条件语句switch"></a>条件语句switch</h3><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。特点：switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止</p><p>细节：</p><p>1、switch分支不需要break，匹配到执行代码块，执行完退出switch</p><p>2、case后面可以有多个表达式，用逗号隔开</p><p>3、后面接的表达式可以是常量，变量，带返回值的函数等</p><p>4、case后的各个表达式的值的数据类型要与switch后的表达式的数据类型一致</p><p>5、case后面表达式如果是常量值，则要求不能重复</p><p>6、default语句不是必须的</p><p>7、switch后也可以不带表达式，类似if—else分支来使用</p><p>8、case中可以对范围进行判断</p><p>9、switch后也可以直接声明&#x2F;定义一个变量，分号结束，不推荐</p><p>10、switch穿透 - fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透</p><p>11、Type Switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 基本用法</span></span><br><span class="line">   <span class="keyword">var</span> age <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age == <span class="number">10</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;age==10&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> age == <span class="number">20</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;age==20&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//8、case中可以对范围进行判断</span></span><br><span class="line">   <span class="keyword">var</span> score <span class="type">int</span> = <span class="number">90</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> score &gt; <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优秀&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> score &gt;= <span class="number">70</span> &amp;&amp; score &lt;= <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优良&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩及格&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//9、switch后也可以直接声明/定义一个变量，分号结束，不推荐</span></span><br><span class="line">   <span class="keyword">switch</span> grade := <span class="number">90</span>; &#123;</span><br><span class="line">      <span class="keyword">case</span> grade &gt; <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优秀&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt;= <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优良&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩及格&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//10、switch穿透 - fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透</span></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">      <span class="keyword">switch</span> num &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">         <span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok2&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//11、Type Switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> y = <span class="number">10.0</span></span><br><span class="line">   x = y</span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x的类型%T\n&quot;</span>, i)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是int型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是float64型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是func(int)型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是bool或string型&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;未知型&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件语句select"><a href="#条件语句select" class="headerlink" title="条件语句select"></a>条件语句select</h3><h3 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h3><p>for循环是一个循环控制结构，可以执行指定次数的循环。</p><p>语法：</p><p>Go语言的For循环有3种形式，只有其中的一种使用分号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">三种形式：</span><br><span class="line">for init; condition; post &#123; &#125;</span><br><span class="line">for condition &#123; &#125;</span><br><span class="line">for &#123; &#125;</span><br><span class="line"></span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line">for语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   // 第一种形式</span><br><span class="line">   for i := 0; i &lt; 10 ; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第二种形式</span><br><span class="line">   // 类似于while循环，go中没有while和do-while</span><br><span class="line">   var i int = 0</span><br><span class="line">   for i &lt; 10 &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      i++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第三种形式</span><br><span class="line">   // 死循环</span><br><span class="line">   for true &#123;</span><br><span class="line">      fmt.Println(&quot;死循环&quot;)</span><br><span class="line">      break</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 循环嵌套</span><br><span class="line">   for i := 0; i &lt; 5 ; i++ &#123;</span><br><span class="line">      for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">         fmt.Println(&quot;i=&quot;, i, &quot;j=&quot;, j)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句range"><a href="#循环语句range" class="headerlink" title="循环语句range"></a>循环语句range</h3><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">   <span class="comment">// 忽略 2nd value，支持 string/array/slice/map。</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">      <span class="built_in">println</span>(s[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略 index。</span></span><br><span class="line">   <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">      <span class="built_in">println</span>(c)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略全部返回值，仅迭代。</span></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">   <span class="comment">// 返回 (key, value)。</span></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">      <span class="built_in">println</span>(k, v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制语句goto、break、continue、return"><a href="#循环控制语句goto、break、continue、return" class="headerlink" title="循环控制语句goto、break、continue、return"></a>循环控制语句goto、break、continue、return</h3><p>循环控制语句可以控制循环体内语句的执行过程。</p><ul><li>goto 语句：通过<code>标签</code>进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</li><li>break 语句：可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加<code>标签</code>，表示退出某个标签对应的代码块，<code>标签</code>要求必须定义在对应的 <code>for</code>、<code>switch</code> 和 <code>select </code>的代码块上。</li><li>continue 语句：可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加<code>标签</code>时，表示开始<code>标签对应的循环</code></li><li>return语句：结束当前函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="type">int</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// i等于count时，使用break退出该循环</span></span><br><span class="line">      <span class="keyword">if</span> i == count &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;退出for循环&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</span></span><br><span class="line">   <span class="comment">// break默认会跳出最近的for循环</span></span><br><span class="line">   <span class="comment">// break后面可以指定标签，跳出标签对应的for循环</span></span><br><span class="line">label2:</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// label1: //设置一个标签</span></span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> j == <span class="number">2</span> &#123; <span class="comment">// j==2的时，跳出标签label2指示的循环</span></span><br><span class="line">            <span class="keyword">break</span> label2</span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// continue使用</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// i为偶数时直接跳过，进入下一次循环</span></span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;奇数是&quot;</span>, i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// goto和return</span></span><br><span class="line">   <span class="keyword">goto</span> label3</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">label3:</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok3&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//return使用在方法或者函数中，表示跳出所在方法或函数</span></span><br><span class="line">   <span class="comment">//如果return是在普通的函数，则表示跳出该函数，即不再执行函数中return后面代码，也可以理解成终止函数</span></span><br><span class="line">   <span class="comment">//如果return是在main函数，表示终止main函数，也就是说终止程序</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;re1&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无需声明原型。</span><br><span class="line">支持不定变参。</span><br><span class="line">支持多返回值。</span><br><span class="line">支持命名返回参数。</span><br><span class="line">支持匿名函数和闭包。</span><br><span class="line">函数也是一种类型，一个函数可以赋值给变量。</span><br><span class="line">不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。</span><br><span class="line">不支持 重载 (overload)</span><br><span class="line">不支持 默认参数 (default parameter)。</span><br><span class="line">当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略</span><br><span class="line">使用关键字 func 定义函数，左大括号依旧不能另起一行。</span><br></pre></td></tr></table></figure><h3 id="函数定义和使用"><a href="#函数定义和使用" class="headerlink" title="函数定义和使用"></a>函数定义和使用</h3><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">    <span class="function"><span class="keyword">func</span>：函数由 <span class="title">func</span> 开始声明</span></span><br><span class="line">    function_name：函数名称，函数名和参数列表一起构成了函数签名。</span><br><span class="line">    parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</span><br><span class="line">    return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</span><br><span class="line">    函数体：函数定义的代码集合。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">int</span>) &#123;</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">   <span class="keyword">return</span> a, b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 函数也可以作为一种数据类型</span></span><br><span class="line">   <span class="keyword">var</span> swap <span class="function"><span class="keyword">func</span><span class="params">(a , b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line">   swap = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> b, a</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(swap(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数和返回值"><a href="#函数参数和返回值" class="headerlink" title="函数参数和返回值"></a>函数参数和返回值</h3><ul><li>形参和实参</li></ul><p>形参：函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参是定义在函数体内的局部变量</p><p>实参：当调用函数，传递过来的变量就是函数的实参</p><ul><li>函数参数传递方式</li></ul><p>函数可以通过两种方式来传递参数：值传递和引用传递</p><p>值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><p>注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。</p><p>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</p><p>值类型：基本数据类型 int系列、float系列、bool、string、数组和结构体struct</p><p>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</p><ul><li>不定参数</li></ul><p>不定参数传值就是函数的参数不是固定的，后面的类型是固定的。（可变参数）</p><p>Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。</p><p>在参数赋值时可以不用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。</p><p>任意类型的不定参数： 就是函数的参数和每个参数的类型都不是固定的。</p><p>用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">string</span>, b ... <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(b[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test(<span class="string">&quot;aaa&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 slice 对象做变参时，必须展开。（slice...）</span></span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   test(<span class="string">&quot;bbb&quot;</span>, s...)    <span class="comment">// slice... 展开slice</span></span><br><span class="line"></span><br><span class="line">   test2(<span class="number">5.21</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持命名返回参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了简化数据类型定义，Go支持自定义数据类型</span></span><br><span class="line"><span class="comment">基本语法：type 自定义数据类型名 数据类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> myFunType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a, b <span class="type">int</span>)</span></span> (sum <span class="type">int</span>)&#123;</span><br><span class="line">   sum = a + b</span><br><span class="line">   <span class="keyword">return</span>  <span class="comment">//因为已经给返回值命名了，所以按照返回值列表的顺序进行返回，不用再指定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(test(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> swap myFunType</span><br><span class="line">   swap = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> b, a</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(swap(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前调用</p><p>执行的流程全局变量定义-&gt;init函数-&gt;main函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程全局变量定义-&gt;init函数-&gt;main函数</span></span><br><span class="line"><span class="keyword">var</span> age = test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了看到全局变量是先被初始化的，我们这里先写函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;test()&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2init函数通常可以在init函数中完成初始化工作</span></span><br><span class="line"><span class="comment">//3main.go和utils.go都含有变量定义、init函数时，执行的流程是先执行调用的包里面的变量定义和init函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;init...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main...age=&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><p>如果某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      fmt.Println(a, <span class="string">&quot;匿名函数&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">   &#125;(<span class="number">2</span>)</span><br><span class="line">   fmt.Println(res) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 可以对匿名函数命名，然后后续进行使用</span></span><br><span class="line">   swap := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">int</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> b, a</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(swap(<span class="number">10</span>,<span class="number">20</span>)) <span class="comment">// 20 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包&#x3D;函数+引用环境)。</p><p>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>闭包复制的是原对象指针，故重复调用闭包可以改变闭包中的变量</p><ul><li>基本用法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 此时c引用了一个环境，此时环境里的变量具有持久性</span></span><br><span class="line">   c := a()</span><br><span class="line">   c()</span><br><span class="line">   c()</span><br><span class="line">   c()</span><br><span class="line"></span><br><span class="line">   a() <span class="comment">//不会输出i</span></span><br><span class="line">   <span class="comment">// 输出 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外部引用函数参数局部变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      base += i</span><br><span class="line">      <span class="keyword">return</span> base</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 此时base会以10进行加</span></span><br><span class="line">   tmp1 := add(<span class="number">10</span>)</span><br><span class="line">   fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>)) <span class="comment">// 11 13</span></span><br><span class="line">   <span class="comment">// 此时tmp1和tmp2不是一个实体了，引用的不用的环境</span></span><br><span class="line">   <span class="comment">// 此时base会以100进行加</span></span><br><span class="line">   tmp2 := add(<span class="number">100</span>)</span><br><span class="line">   fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>)) <span class="comment">// 101 103</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回2个闭包</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">   <span class="comment">// 相加</span></span><br><span class="line">   add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      base += i</span><br><span class="line">      <span class="keyword">return</span> base</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 相减</span></span><br><span class="line">   sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      base -= i</span><br><span class="line">      <span class="keyword">return</span> base</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回</span></span><br><span class="line">   <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 引用的环境一直没有改变</span></span><br><span class="line">   f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">   <span class="comment">// base一直是没有消</span></span><br><span class="line">   fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">// 11 9</span></span><br><span class="line">   <span class="comment">// 此时base是9</span></span><br><span class="line">   fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">// 12 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归，就是在运行的过程中调用自己。 一个函数调用自己，就叫做递归函数。</p><p>构成递归需具备的条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.子问题须与原始问题为同样的事，且更为简单。</span><br><span class="line">2.不能无限制地调用本身，须有个出口，化简为非递归状况处理。</span><br></pre></td></tr></table></figure><p>斐波拉契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonaci</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, fibonaci(i))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h3><p><code>defer</code>是go语言中，一个特殊的关键字，用于<code>延迟调用</code>。</p><p>延迟调用：让函数或方法（跟在defer后的函数，我们一般称之为延迟函数）在当前函数执行完毕后但在<code>return</code>或者<code>panic之前</code>执行。</p><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、当执行defer时，暂时不执行，会将defer后面的语句压入到独立的栈(defer栈)</span><br><span class="line">当函数执行完毕后，再从defer栈，按照先进后出的方式出栈，执行</span><br><span class="line">2、defer语句中的变量，在defer声明时就决定了。</span><br></pre></td></tr></table></figure><p>用途：资源释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 关闭文件句柄</span><br><span class="line">2. 锁资源释放</span><br><span class="line">3. 数据库连接释放</span><br></pre></td></tr></table></figure><p>与闭包使用的问题：</p><p>闭包有一个独立的环境，但是此时的闭包都同时引用的i，即使是不同的环境，i的改变，都会引起不同闭包的改变，最后循环结束，i为4，所以此时5个闭包输出都是4</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">      <span class="comment">// 此时5个闭包都引用的同一个i，故循环结束后i为4</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出： 4 4 4 4 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：将i复制一份，再传给闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">      temp := i</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         fmt.Println(temp)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出： 4 3 2 1 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h1><h1 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h1 id="defer和time"><a href="#defer和time" class="headerlink" title="defer和time"></a>defer和time</h1><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股文</title>
      <link href="/2024/04/10/C++/C-%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/04/10/C++/C-%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="简述下C-语言的特点"><a href="#简述下C-语言的特点" class="headerlink" title="简述下C++语言的特点"></a>简述下C++语言的特点</h2><ol><li>引入了面向对象的机制，同时兼容了C语言</li><li>C++有三大特性：封装、继承、多态</li><li>C++可复用性高，引入了模板</li></ol><h2 id="C和C-有什么区别"><a href="#C和C-有什么区别" class="headerlink" title="C和C++有什么区别"></a>C和C++有什么区别</h2><ol><li>C++是面向对象的语言，而C是面向过程的语言；</li><li>C++引入new&#x2F;delete运算符，取代了C中的malloc&#x2F;free库函数；</li><li>C++引入引用的概念，而C中没有；</li><li>C++引入类的概念，而C中没有；</li><li>C++引入函数重载的特性，而C中没有</li></ol><h2 id="说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h2><ol><li>尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li><li>编译器预处理阶段查找头文件的路径不一样。</li></ol><h2 id="说一说extern-“C”"><a href="#说一说extern-“C”" class="headerlink" title="说一说extern “C”"></a>说一说extern “C”</h2><ol><li>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。</li><li>加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。</li></ol><h2 id="C-编译时和C有什么不同？"><a href="#C-编译时和C有什么不同？" class="headerlink" title="C++编译时和C有什么不同？"></a>C++编译时和C有什么不同？</h2><ol><li>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；</li><li>而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</li></ol><h2 id="简述C-从代码到可执行二进制文件的过程"><a href="#简述C-从代码到可执行二进制文件的过程" class="headerlink" title="简述C++从代码到可执行二进制文件的过程"></a>简述C++从代码到可执行二进制文件的过程</h2><p>一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接。<br>预编译：这个过程主要的处理操作如下：<br>（1）  将所有的#define删除，并且展开所有的宏定义<br>（2）  处理所有的条件预编译指令，如#if、#ifdef<br>（3）  处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。<br>（4）  过滤所有的注释<br>（5）  添加行号和文件名标识。<br>编译：这个过程主要的处理操作如下：<br>（1）  词法分析：将源代码的字符序列分割成一系列的记号。<br>（2）  语法分析：对记号进行语法分析，产生语法树。<br>（3）  语义分析：判断表达式是否有意义。<br>（4）  代码优化：<br>（5）  目标代码生成：生成汇编代码。<br>（6）  目标代码优化：<br>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。<br>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。<br>链接分为静态链接和动态链接。<br>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。<br>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p><h2 id="静态链接和动态链接有什么区别？"><a href="#静态链接和动态链接有什么区别？" class="headerlink" title="静态链接和动态链接有什么区别？"></a>静态链接和动态链接有什么区别？</h2><ol><li>静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；<br>优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；</li><li>动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；<br>优点在于多个程序可以共享同一个动态库，节省资源；<br>缺点在于由于运行时加载，可能影响程序的前期执行性能。</li></ol><h2 id="说说static关键字的作用"><a href="#说说static关键字的作用" class="headerlink" title="说说static关键字的作用"></a>说说static关键字的作用</h2><p>static用于声明变量的存储期和可见性</p><ol><li>修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；</li><li>修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；</li><li>修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；</li><li>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；</li><li>修饰成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。</li></ol><h2 id="C语言的关键字static和C-的关键字static有什么区别"><a href="#C语言的关键字static和C-的关键字static有什么区别" class="headerlink" title="C语言的关键字static和C++的关键字static有什么区别"></a>C语言的关键字static和C++的关键字static有什么区别</h2><p>在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。<br>「注意」：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。</p><h2 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h2><ol><li>概念：<br> 数组：数组是用于存储多个类型相同的数据集合。数组名是首元素的地址<br> 指针：指针相当于一个变量，但是和其他变量不一样，它存放的是其他变量在内存中的地址。指针名指向了内存的首地址。</li><li>区别：<br> 赋值：同类型指针变量可以相互赋值；数组只能一个一个元素的赋值或拷贝<br> 求sizeof：无论指针的类型是什么，sizeof的大小要么是4，要么是8；数组所占存储空间的内存大小：sizeof(数组名)&#x2F;sizeof(数据类型)</li></ol><p>int a[3][4];<br>int (<em>p)[4];  &#x2F;&#x2F;该语句是定义一个数组指针，指向含4个元素的一维数组<br>p &#x3D; a;        &#x2F;&#x2F;将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]<br>p++;          &#x2F;&#x2F;该语句执行过后，也就是p&#x3D;p+1；p跨过行a[0][]指向了行a[1][]<br>              &#x2F;&#x2F;所以数组指针也称指向一维数组的指针，亦称行指针。<br>&#x2F;&#x2F;访问数组中第i行j列的一个元素，有几种操作方式：<br>&#x2F;&#x2F;</em>(p[i]+j)、*(<em>(p+i)+j)、(</em>(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。<br>&#x2F;&#x2F;这几种操作方式都是合法的。</p><h2 id="简述指针常量与常量指针的区别"><a href="#简述指针常量与常量指针的区别" class="headerlink" title="简述指针常量与常量指针的区别"></a>简述指针常量与常量指针的区别</h2><ol><li>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。</li><li>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。<br>「注意」：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</li></ol><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>可以有const指针，但是没有引用常量；（具体解释看评论区）</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li><li>指针可以有多级指针（**p），而引用止于一级；</li><li>指针和引用使用++运算符的意义不一样；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h2 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针"></a>什么是函数指针</h2><ol><li>概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。<br>定义形式如下：<br>int func(int a); int (*f)(int a); f &#x3D; &func;</li><li>函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li></ol><h2 id="说说什么是野指针，怎么产生的，如何避免？"><a href="#说说什么是野指针，怎么产生的，如何避免？" class="headerlink" title="说说什么是野指针，怎么产生的，如何避免？"></a>说说什么是野指针，怎么产生的，如何避免？</h2><p>概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。<br>避免办法：<br>（1）初始化置NULL<br>（2）申请内存后判空<br>（3）指针释放后置NULL<br>（4）使用智能指针</p><h2 id="悬挂指针与野指针有什么区别？"><a href="#悬挂指针与野指针有什么区别？" class="headerlink" title="悬挂指针与野指针有什么区别？"></a>悬挂指针与野指针有什么区别？</h2><ol><li>悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</li><li>野指针：未初始化的指针被称为野指针。</li></ol><h2 id="全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？"><a href="#全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？" class="headerlink" title="全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？"></a>全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？</h2><ol><li>全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；</li><li>而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</li><li>操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。</li></ol><h2 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h2><ol><li>宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li><li>宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li>宏定义是没有类型检查的，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li></ol><h2 id="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"><a href="#对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？" class="headerlink" title="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"></a>对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？</h2><p>应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。<br>优点：</p><ol><li>在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；</li><li>相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；<br>缺点：</li><li>代码膨胀，产生更多的开销；</li><li>如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；</li><li>如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；</li><li>内联声明只是建议，是否内联由编译器决定，所以实际并不可控。</li></ol><h2 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i++和++i的区别"></a>说说运算符i++和++i的区别</h2><ol><li>赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</li><li>效率不同：后置++执行速度比前置的慢。</li><li>i++ 不能作为左值，而++i 可以</li><li>两者都不是原子操作。（原子操作是指一个不受其他操作影响的操作任务单元）</li></ol><h2 id="C-的顶层const和底层const-？"><a href="#C-的顶层const和底层const-？" class="headerlink" title="C++的顶层const和底层const ？"></a>C++的顶层const和底层const ？</h2><ol><li>底层const是代表指针的指向可以改变，指向的值不可以改变；（常量指针）</li><li>顶层const是代表指针的指向不可改变，指向的值可以改变。（指向不可改变）；（指针常量）</li></ol><h2 id="说说const和define的区别"><a href="#说说const和define的区别" class="headerlink" title="说说const和define的区别"></a>说说const和define的区别</h2><ol><li>const生效于编译的阶段；define生效于预处理阶段。</li><li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</li><li>const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</li><li>定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效。</li></ol><h2 id="typedef-和define-有什么区别"><a href="#typedef-和define-有什么区别" class="headerlink" title="typedef 和define 有什么区别"></a>typedef 和define 有什么区别</h2><ul><li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义 常量，以及书写复杂使用频繁的宏。</li><li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li><li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。</li><li>对指针的操作不同：typedef 和define 定义的指针时有很大的区别。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_INT int*  </span></span><br><span class="line">PTR_INT p, q; <span class="comment">// 这实际上等价于 int* p, q; p是int*类型，q是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PTR_INT;  </span><br><span class="line">PTR_INT p, q; <span class="comment">// 这里p和q都是int*类型的指针</span></span><br></pre></td></tr></table></figure>「注意」：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。</li></ul><h2 id="说说C-中函数指针和指针函数的区别"><a href="#说说C-中函数指针和指针函数的区别" class="headerlink" title="说说C++中函数指针和指针函数的区别"></a>说说C++中函数指针和指针函数的区别</h2><ol><li>指针函数本质是一个函数，其返回值为指针。</li><li>函数指针本质是一个指针，其指向一个函数。</li></ol><h2 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h2><ol><li>变量的定义为变量分配地址和存储空间，</li><li>变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。</li><li>加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。<br>说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</li></ol><h2 id="简述-ifdef、-else、-endif和-ifndef的作用"><a href="#简述-ifdef、-else、-endif和-ifndef的作用" class="headerlink" title="简述#ifdef、#else、#endif和#ifndef的作用"></a>简述#ifdef、#else、#endif和#ifndef的作用</h2><ol><li>利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。</li><li>在子程序前加上标记，以便于追踪和调试。<br>条件编译就是为了实现在满足一定条件时编译某一组语句，而再不满足条件时编译另一组语句！<br>结构体可以直接赋值吗<br>声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="type">int</span> y;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Point p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">    Point p2;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 在C++中，可以直接对整个结构体进行赋值  </span></span><br><span class="line">    p2 = p1;  </span><br><span class="line">      </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2.x = &quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, p2.y = &quot;</span> &lt;&lt; p2.y &lt;&lt; std::endl;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>「注意」：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。</li></ol><h2 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof 和strlen 的区别"></a>sizeof 和strlen 的区别</h2><ol><li>sizeof是一个操作符，strlen是库函数。</li><li>sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。</li><li>编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。</li><li>数组做sizeof的参数不退化，传递给strlen就退化为指针了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];  </span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(arr); <span class="comment">// size 将会是 10 * sizeof(int)，即数组整个大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// len 将会是 5，因为 &quot;Hello&quot; 有5个字符（不包括结尾的 &#x27;\0&#x27;）</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="一个参数可以既是const又是volatile吗"><a href="#一个参数可以既是const又是volatile吗" class="headerlink" title="一个参数可以既是const又是volatile吗"></a>一个参数可以既是const又是volatile吗</h2><p>可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。<br>注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。</p><h2 id="简述strcpy、sprintf-与memcpy-的区别"><a href="#简述strcpy、sprintf-与memcpy-的区别" class="headerlink" title="简述strcpy、sprintf 与memcpy 的区别"></a>简述strcpy、sprintf 与memcpy 的区别</h2><ol><li>操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li><li>执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。</li><li>实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。<br>「注意」：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, dest);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];  </span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="type">float</span> b = <span class="number">20.5</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Integer: %d, Float: %.2f&quot;</span>, a, b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="number">7</span>);  <span class="comment">// 只复制前7个字符  </span></span><br><span class="line">    dest[<span class="number">7</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加终止字符  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied bytes: %s\n&quot;</span>, dest);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="请解析-void-0-的含义"><a href="#请解析-void-0-的含义" class="headerlink" title="请解析((void ()( ) )0)( )的含义"></a>请解析((void ()( ) )0)( )的含义</h2><ol><li>void (*0)( ) ：是一个返回值为void，参数为空的函数指针0。</li><li>(void (*)( ))0：把0转变成一个返回值为void，参数为空的函数指针。</li><li><em>(void(</em>)())0：在上句的基础上加*表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。</li><li>(<em>(void (</em>)( ))0)( )：这就是上句的函数名所对应的函数的调用。</li></ol><h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h2><p>分配和管理方式不同：</p><ul><li>堆是动态分配的，其空间的分配和释放都由程序员控制；</li><li>栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由alloca()函数进行分配，但是会由编译器释放；<br>产生碎片不同：</li><li>对堆来说，频繁使用new&#x2F;delete或者malloc&#x2F;free会造成内存空间的不连续，产生大量碎片，使程序效率降低；</li><li>对栈来说，不存在碎片问题，因为栈具有先进后出的特性；<br>生长方向不同：</li><li>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；</li><li>栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；<br>申请大小限制不同：</li><li>栈顶和栈底是预设好的，大小固定；</li><li>堆是不连续的内存区域，其大小可以灵活调整</li></ul><h2 id="内存的分配方式有几种？"><a href="#内存的分配方式有几种？" class="headerlink" title="内存的分配方式有几种？"></a>内存的分配方式有几种？</h2><ol><li>在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限；</li><li>从堆上分配：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</li><li>从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价</li><li>从常量存储区分配：特殊的存储区，存放的是常量，不可修改；</li><li>从全局&#x2F;静态存储区分配：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</li></ol><h2 id="内存泄漏的场景有哪些？"><a href="#内存泄漏的场景有哪些？" class="headerlink" title="内存泄漏的场景有哪些？"></a>内存泄漏的场景有哪些？</h2><p>内存泄露：简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p><ol><li>malloc和free未成对出现；new&#x2F;new []和delete&#x2F;delete []未成对出现；</li><li>未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的；</li><li>没有将基类的析构函数定义为虚函数。</li></ol><h2 id="malloc和局部变量分配在堆还是栈？"><a href="#malloc和局部变量分配在堆还是栈？" class="headerlink" title="malloc和局部变量分配在堆还是栈？"></a>malloc和局部变量分配在堆还是栈？</h2><p>malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。</p><h2 id="程序有哪些section，分别的作用？"><a href="#程序有哪些section，分别的作用？" class="headerlink" title="程序有哪些section，分别的作用？"></a>程序有哪些section，分别的作用？</h2><p>从低地址到高地址，一个程序由代码段、数据段、 BSS 段组成。</p><ol><li>数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。</li><li>代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</li><li>BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。<br>可执行程序在运行时又会多出两个区域：堆区和栈区。</li><li>堆区：动态申请内存用。堆从低地址向高地址增长。</li><li>栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</li><li>最后还有一个文件映射区，位于堆和栈之间。</li></ol><h2 id="初始化为0的全局变量在bss还是data"><a href="#初始化为0的全局变量在bss还是data" class="headerlink" title="初始化为0的全局变量在bss还是data"></a>初始化为0的全局变量在bss还是data</h2><p>BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。</p><h2 id="new-delete和malloc-free之间有什么关系？"><a href="#new-delete和malloc-free之间有什么关系？" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free之间有什么关系？"></a>new&#x2F;delete和malloc&#x2F;free之间有什么关系？</h2><ul><li>new与delete直接返回带具体类型的指针，malloc和free返回void类型的指针。</li><li>new类型是安全的，而malloc不是。例如int *p &#x3D; new float[2];就会报错；而int <em>p &#x3D; malloc(2</em>sizeof(int))编译时编译器就无法指出错误来。</li><li>new一般分为两步：new操作和构造。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。</li><li>new调用构造函数，malloc不能；delete调用析构函数，而free不能。</li><li>malloc&#x2F;free需要库文件stdlib.h的支持，new&#x2F;delete则不需要！<br>「注意」：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。</li></ul><h2 id="delete与delete-有什么区别？"><a href="#delete与delete-有什么区别？" class="headerlink" title="delete与delete []有什么区别？"></a>delete与delete []有什么区别？</h2><ol><li>对于简单类型来说，使用new分配后，不管是数组还是非数组形式，两种方式都可以释放内存：<br>对于自定义类型来说，就需要对于单个对象使用delete，对于对象数组使用delete []，逐个调用数组中对象的析构函数，从而释放所有内存；</li><li>如果反过来使用，即对于单个对象使用delete []，对于对象数组使用delete，其行为是未定义的；</li><li>所以，最恰当的方式就是如果用了new，就用delete；如果用了new []，就用delete []。<br>内存块太小导致malloc和new返回空指针，该怎么处理？</li><li>对于malloc来说，需要判断其是否返回空指针，如果是则马上用return语句终止该函数或者exit终止该程序；<br>对于new来说，默认抛出异常，所以可以使用try…catch…代码块的方式</li><li>还可以使用set_new_handler函数的方式</li></ol><h2 id="静态内存分配和动态内存分配有什么区别？"><a href="#静态内存分配和动态内存分配有什么区别？" class="headerlink" title="静态内存分配和动态内存分配有什么区别？"></a>静态内存分配和动态内存分配有什么区别？</h2><ol><li>静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；</li><li>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；</li><li>静态内存分配不需要指针或引用类型的支持；动态内存分配需要；</li><li>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；</li><li>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；</li><li>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。</li></ol><h2 id="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"><a href="#如何构造一个类，使得只能在堆上或只能在栈上分配内存？" class="headerlink" title="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"></a>如何构造一个类，使得只能在堆上或只能在栈上分配内存？</h2><ol><li>只能在堆上分配内存：将析构函数声明为private；（编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。所以将析构函数声明为private，不可访问，就无法将对象创建在栈上）</li><li>只能在栈上生成对象：将new和delete重载为private。（只要禁用new运算符就能够实现类对象只能创建在栈上）</li></ol><h2 id="在C-中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？"><a href="#在C-中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？" class="headerlink" title="在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？"></a>在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？</h2><p>不能。<br>malloc &#x2F;free主要为了兼容C，new和delete 完全可以取代malloc &#x2F;free的。malloc &#x2F;free的操作对象都是必须明确大小的。<br>而且不能用在动态类上。new 和delete会自动进行类型检查，也不需要自己明确内存大小，malloc&#x2F;free不能执行构造函数与析构函数，所以动态对象它是不行的。<br>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p><h2 id="简述C-中内存对齐"><a href="#简述C-中内存对齐" class="headerlink" title="简述C++中内存对齐"></a>简述C++中内存对齐</h2><ol><li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li><li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li><li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</li><li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li></ol><h2 id="为什么需要内存对齐呢？"><a href="#为什么需要内存对齐呢？" class="headerlink" title="为什么需要内存对齐呢？"></a>为什么需要内存对齐呢？</h2><p>因为CPU在访问内存时，并不是以单个字节为单位来访问的，而是以更大的数据块（例如4字节或8字节）为单位。如果数据的内存地址不是对齐的，那么CPU可能需要两次或更多的内存访问才能读取或写入数据，这会导致额外的开销。而通过对齐数据，CPU可以一次访问就读取或写入整个数据，从而提高了效率。</p><h2 id="说说new和malloc的区别，各自底层实现原理。"><a href="#说说new和malloc的区别，各自底层实现原理。" class="headerlink" title="说说new和malloc的区别，各自底层实现原理。"></a>说说new和malloc的区别，各自底层实现原理。</h2><p>malloc底层实现：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K  时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。<br>new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p><ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h2><p>面向对象是一种编程思想，把一切东西看成是一个个对象，他们各自都有属性，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示<br>面向过程：根据业务逻辑从上到下写代码<br>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p><h2 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h2><ol><li>封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。</li><li>继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；</li><li>多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。对开放扩展，对修改关闭（开闭原则）</li></ol><h2 id="C-中类成员的访问权限"><a href="#C-中类成员的访问权限" class="headerlink" title="C++中类成员的访问权限"></a>C++中类成员的访问权限</h2><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。<br>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p><h2 id="说说类继承时，派生类对不同关键字修饰的基类方法的访问权限"><a href="#说说类继承时，派生类对不同关键字修饰的基类方法的访问权限" class="headerlink" title="说说类继承时，派生类对不同关键字修饰的基类方法的访问权限"></a>说说类继承时，派生类对不同关键字修饰的基类方法的访问权限</h2><p>类中的成员可以分为三种类型，分别为public成员、protected成员、private成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。<br>public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</p><ol><li>派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。<br>protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li><li>派生类对象不可以访问基类的public、protected、private成员。<br>private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li><li>派生类对象不可以访问基类的public、protected、private成员。</li></ol><h2 id="多态的实现有哪几种？"><a href="#多态的实现有哪几种？" class="headerlink" title="多态的实现有哪几种？"></a>多态的实现有哪几种？</h2><p>多态分为静态多态和动态多态。<br>其中，静态多态是通过重载和模板技术实现的，在编译期间确定；<br>动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。</p><h2 id="动态绑定是如何实现的？"><a href="#动态绑定是如何实现的？" class="headerlink" title="动态绑定是如何实现的？"></a>动态绑定是如何实现的？</h2><p>当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。</p><h2 id="动态多态有什么作用？有哪些必要条件？"><a href="#动态多态有什么作用？有哪些必要条件？" class="headerlink" title="动态多态有什么作用？有哪些必要条件？"></a>动态多态有什么作用？有哪些必要条件？</h2><p>动态多态的作用：</p><ul><li>隐藏实现细节，使代码模块化，提高代码的可复用性；</li><li>接口重用，使派生类的功能可以被基类的指针&#x2F;引用所调用，即向后兼容，提高代码的可扩充性和可维护性。<br>动态多态的必要条件：</li><li>需要有继承；</li><li>需要有虚函数覆盖；</li><li>需要有基类指针&#x2F;引用指向子类对象</li></ul><h2 id="虚函数表里存放的内容是什么时候写进去的？"><a href="#虚函数表里存放的内容是什么时候写进去的？" class="headerlink" title="虚函数表里存放的内容是什么时候写进去的？"></a>虚函数表里存放的内容是什么时候写进去的？</h2><ol><li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr（虚函数指针），然后调用构造函数。即：虚表在构造函数之前写入</li><li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动态多态提供支持。</li></ol><h2 id="对虚函数和多态的理解"><a href="#对虚函数和多态的理解" class="headerlink" title="对虚函数和多态的理解"></a>对虚函数和多态的理解</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><h2 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h2><p>虚函数表是针对类的，<br>类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。</p><h2 id="为什么基类的构造函数不能定义为虚函数？"><a href="#为什么基类的构造函数不能定义为虚函数？" class="headerlink" title="为什么基类的构造函数不能定义为虚函数？"></a>为什么基类的构造函数不能定义为虚函数？</h2><p>虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。<br>为什么基类的析构函数需要定义为虚函数？<br>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p><h2 id="纯虚函数有什么作用？如何实现？"><a href="#纯虚函数有什么作用？如何实现？" class="headerlink" title="纯虚函数有什么作用？如何实现？"></a>纯虚函数有什么作用？如何实现？</h2><p>定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。<br>实现方式是在虚函数声明的结尾加上&#x3D; 0即可。</p><h2 id="说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"><a href="#说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？" class="headerlink" title="说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"></a>说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h2><ol><li>纯虚函数不可以实例化，但是可以用其派生类实例化</li><li>虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。<br>即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”<br>所以纯虚函数不能实例化。</li><li>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</li><li>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ol><h2 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h2><ol><li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li><li>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</li><li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li><li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</li><li>虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual  { } &#x3D; 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li></ol><h2 id="请问构造函数中的能不能调用虚方法"><a href="#请问构造函数中的能不能调用虚方法" class="headerlink" title="请问构造函数中的能不能调用虚方法"></a>请问构造函数中的能不能调用虚方法</h2><p>不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。<br>同样，进入基类析构函数时，对象也是基类类型。<br>所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h2 id="C-中哪些函数不能被声明为虚函数？"><a href="#C-中哪些函数不能被声明为虚函数？" class="headerlink" title="C++ 中哪些函数不能被声明为虚函数？"></a>C++ 中哪些函数不能被声明为虚函数？</h2><p>常见的不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p><ol><li>为什么C++不支持普通函数为虚函数？<br>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</li><li>为什么C++不支持构造函数为虚函数？<br>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual  function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）<br>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</li><li>为什么C++不支持内联成员函数为虚函数？<br>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）</li><li>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</li><li>为什么C++不支持静态成员函数为虚函数？<br>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。<br>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</li><li>为什么C++不支持友元函数为虚函数？<br>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</li></ol><h2 id="构造函数和析构函数能抛出异常吗？"><a href="#构造函数和析构函数能抛出异常吗？" class="headerlink" title="构造函数和析构函数能抛出异常吗？"></a>构造函数和析构函数能抛出异常吗？</h2><ul><li>从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。如果在构造函数的执行过程中抛出了异常，并且这个异常没有被捕获，那么该对象的析构函数将不会被调用，这可能导致资源泄露</li><li>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。</li></ul><h2 id="请问拷贝构造函数的参数是什么传递方式，为什么"><a href="#请问拷贝构造函数的参数是什么传递方式，为什么" class="headerlink" title="请问拷贝构造函数的参数是什么传递方式，为什么"></a>请问拷贝构造函数的参数是什么传递方式，为什么</h2><ol><li>拷贝构造函数的参数必须使用引用传递<br>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass  c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</li><li>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</li></ol><h2 id="如何让一个类不能实例化？"><a href="#如何让一个类不能实例化？" class="headerlink" title="如何让一个类不能实例化？"></a>如何让一个类不能实例化？</h2><p>将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。<br>多继承存在什么问题？如何消除多继承中的二义性？</p><ol><li>增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；</li><li>在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；<br>消除同名二义性的方法：</li></ol><ul><li>利用作用域运算符::，用于限定派生类使用的是哪个基类的成员；</li><li>在派生类中定义同名成员，覆盖基类中的相关成员；<br>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；<br>消除路径二义性的方法：</li><li>消除同名二义性的两种方法都可以；</li><li>使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。</li></ul><h2 id="如果类A是一个空类，那么sizeof-A-的值为多少？"><a href="#如果类A是一个空类，那么sizeof-A-的值为多少？" class="headerlink" title="如果类A是一个空类，那么sizeof(A)的值为多少？"></a>如果类A是一个空类，那么sizeof(A)的值为多少？</h2><p>sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。</p><h2 id="覆盖和重载之间有什么区别？"><a href="#覆盖和重载之间有什么区别？" class="headerlink" title="覆盖和重载之间有什么区别？"></a>覆盖和重载之间有什么区别？</h2><ul><li>覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别；覆盖只发生在类的成员函数中；</li><li>重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。</li></ul><h2 id="拷贝构造函数和赋值运算符重载之间有什么区别？"><a href="#拷贝构造函数和赋值运算符重载之间有什么区别？" class="headerlink" title="拷贝构造函数和赋值运算符重载之间有什么区别？"></a>拷贝构造函数和赋值运算符重载之间有什么区别？</h2><p>拷贝构造函数用于构造新的对象；<br>Student s;Student s1 &#x3D; s; &#x2F;&#x2F; 隐式调用拷贝构造函数Student s2(s);  &#x2F;&#x2F; 显式调用拷贝构造函数<br>赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且源对象中包含未释放的内存时需要先将其释放；<br>Student s;Student s1;s1 &#x3D; s; &#x2F;&#x2F; 使用赋值运算符<br>一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。</p><h2 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h2><ul><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。</li></ul><h2 id="请你来说一下C-中struct和class的区别"><a href="#请你来说一下C-中struct和class的区别" class="headerlink" title="请你来说一下C++中struct和class的区别"></a>请你来说一下C++中struct和class的区别</h2><p>在C++中，class和struct做类型定义如下区别：</p><ul><li>默认继承权限不同，class继承默认是private继承，而struct默认是public继承</li><li>class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数</li></ul><h2 id="简述类成员函数的重写、重载和隐藏的区别"><a href="#简述类成员函数的重写、重载和隐藏的区别" class="headerlink" title="简述类成员函数的重写、重载和隐藏的区别"></a>简述类成员函数的重写、重载和隐藏的区别</h2><p>（1）重写和重载主要有以下几点不同。</p><ul><li>范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。</li><li>参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一 定不同。</li><li>virtual 的区别：重写的基类中被重写的函数必须要有virtual 修饰，而重载函数和被重载函数可以被 virtual 修饰，也可以没有。<br>（2）隐藏和重写、重载有以下几点不同。</li><li>与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。</li><li>参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的函数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。<br>「注意」：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。</li></ul><h2 id="RTTI是什么？其原理是什么？"><a href="#RTTI是什么？其原理是什么？" class="headerlink" title="RTTI是什么？其原理是什么？"></a>RTTI是什么？其原理是什么？</h2><p>RTTI即运行时类型识别，其功能由两个运算符实现：</p><ul><li>typeid运算符，用于返回表达式的类型，可以通过基类的指针获取派生类的数据类型；</li><li>dynamic_cast运算符，具有类型检查的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li></ul><h2 id="C-的空类有哪些成员函数"><a href="#C-的空类有哪些成员函数" class="headerlink" title="C++的空类有哪些成员函数"></a>C++的空类有哪些成员函数</h2><ul><li>缺省构造函数。</li><li>缺省拷贝构造函数。</li><li>析构函数。</li><li>赋值运算符。</li><li>取址运算符。</li><li>取址运算符 const 。<br>「注意」：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。</li></ul><h2 id="说说-C-类对象的初始化顺序，有多重继承情况下的顺序"><a href="#说说-C-类对象的初始化顺序，有多重继承情况下的顺序" class="headerlink" title="说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序"></a>说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序</h2><p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数<br>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。<br>析构顺序和构造顺序相反。</p><h2 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h2><ol><li>子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；</li><li>父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</li></ol><h2 id="简述下深拷贝和浅拷贝，如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝，如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝，如何实现深拷贝"></a>简述下深拷贝和浅拷贝，如何实现深拷贝</h2><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；<br>而深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。</p><h2 id="简述一下移动构造函数"><a href="#简述一下移动构造函数" class="headerlink" title="简述一下移动构造函数"></a>简述一下移动构造函数</h2><p>C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。<br>移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。<br>而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p><h2 id="简述一下拷贝赋值和移动赋值？"><a href="#简述一下拷贝赋值和移动赋值？" class="headerlink" title="简述一下拷贝赋值和移动赋值？"></a>简述一下拷贝赋值和移动赋值？</h2><ol><li>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。<br>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</li><li>拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</li><li>拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</li></ol><h2 id="请你回答一下-C-类内可以定义引用数据成员吗？"><a href="#请你回答一下-C-类内可以定义引用数据成员吗？" class="headerlink" title="请你回答一下 C++ 类内可以定义引用数据成员吗？"></a>请你回答一下 C++ 类内可以定义引用数据成员吗？</h2><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p><ol><li>不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。</li><li>构造函数的形参也必须是引用类型。</li><li>不能在构造函数里初始化，必须在初始化列表中进行初始化。</li></ol><h2 id="简述一下什么是常函数，有什么作用"><a href="#简述一下什么是常函数，有什么作用" class="headerlink" title="简述一下什么是常函数，有什么作用"></a>简述一下什么是常函数，有什么作用</h2><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。<br>有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员<br>常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p><h2 id="仿函数了解吗？有什么作用"><a href="#仿函数了解吗？有什么作用" class="headerlink" title="仿函数了解吗？有什么作用"></a>仿函数了解吗？有什么作用</h2><p>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符</p><h2 id="模板实例化和模板特例化"><a href="#模板实例化和模板特例化" class="headerlink" title="模板实例化和模板特例化"></a>模板实例化和模板特例化</h2><p>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的<br>模板特例化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行特例化。特例化时可以修改原模板的定义，当使用该类型时，按照特例化后的定义实现，特例化相当于对某种类型进行特殊处理。</p><h2 id="解释下-C-中类模板和模板类的区别"><a href="#解释下-C-中类模板和模板类的区别" class="headerlink" title="解释下 C++ 中类模板和模板类的区别"></a>解释下 C++ 中类模板和模板类的区别</h2><ol><li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li><li>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</li></ol><h1 id="STL特性"><a href="#STL特性" class="headerlink" title="STL特性"></a>STL特性</h1><h2 id="什么是C-STL？"><a href="#什么是C-STL？" class="headerlink" title="什么是C++ STL？"></a>什么是C++ STL？</h2><p>STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p><ol><li>容器(Container)<br>是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。 </li><li>算法（Algorithm）<br>是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。 </li><li>迭代器（Iterator）<br>提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。  迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。  但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象; </li><li>仿函数（Function object）<br>仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。 </li><li>适配器（Adaptor）<br>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。 </li><li>空间配制器（Allocator）<br>为STL提供空间配置的系统。其中主要工作包括两部分：<br>（1）对象的创建与销毁<br>（2）内存的获取与释放。</li></ol><h2 id="请说说-STL-中常见的容器，并介绍一下实现原理"><a href="#请说说-STL-中常见的容器，并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器，并介绍一下实现原理"></a>请说说 STL 中常见的容器，并介绍一下实现原理</h2><p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p><ol><li>顺序容器<br>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：<br>（1）vector    头文件<br>动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。<br>（2）deque    头文件<br>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。<br>（3）list    头文件<br>双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li><li>关联式容器<br>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：<br>（1）set&#x2F;multiset    头文件<br>set 即集合。set中不允许相同元素，multiset中允许存在相同元素。<br>（2）map&#x2F;multimap    头文件<br>map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。<br>注意：map同multimap的不同在于是否允许相同first值的元素。</li><li>容器适配器<br>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：<br>（1）stack    头文件<br>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。<br>（2）queue    头文件<br>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。<br>（3）priority_queue    头文件<br>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</li></ol><h2 id="什么时候需要用hash-map，什么时候需要用map"><a href="#什么时候需要用hash-map，什么时候需要用map" class="headerlink" title="什么时候需要用hash_map，什么时候需要用map?"></a>什么时候需要用hash_map，什么时候需要用map?</h2><p>总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。<br>但是并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，如果考虑效率，特别是在元素达到一定数量级时，考虑 用hash_map。<br>但若对内存使用特别严格，希望程序尽可能少消耗内存，那么hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，就更无法控制了。而且hash_map 的构造速度较慢。</p><h2 id="vector的底层原理"><a href="#vector的底层原理" class="headerlink" title="vector的底层原理"></a>vector的底层原理</h2><p>vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。<br>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。<br>当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。<br>因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。</p><h2 id="vector中的reserve和resize的区别"><a href="#vector中的reserve和resize的区别" class="headerlink" title="vector中的reserve和resize的区别"></a>vector中的reserve和resize的区别</h2><p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。<br>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。<br>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。<br>reserve 函数用于预先分配内存空间，而 resize 函数用于改变 std::vector 的大小。</p><h2 id="vector中的size和capacity的区别"><a href="#vector中的size和capacity的区别" class="headerlink" title="vector中的size和capacity的区别"></a>vector中的size和capacity的区别</h2><p>size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。</p><h2 id="vector的元素类型可以是引用吗？"><a href="#vector的元素类型可以是引用吗？" class="headerlink" title="vector的元素类型可以是引用吗？"></a>vector的元素类型可以是引用吗？</h2><p>vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。</p><h2 id="vector迭代器失效的情况"><a href="#vector迭代器失效的情况" class="headerlink" title="vector迭代器失效的情况"></a>vector迭代器失效的情况</h2><p>当插入一个元素到vector中，如果引起了内存重新分配，所以指向原内存的迭代器全部失效。<br>当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it&#x3D;vec.erase(it);。</p><h2 id="vector循环删除元素正确方式"><a href="#vector循环删除元素正确方式" class="headerlink" title="vector循环删除元素正确方式"></a>vector循环删除元素正确方式</h2><p>在C++中，循环删除std::vector中的元素时，确实需要注意不要破坏迭代器或索引的有效性。下面提供了几种正确循环删除vector中元素的方法：<br>1、方法一：从后向前遍历并删除<br>从后向前遍历vector并删除奇数位元素是一种安全的方法，因为删除操作不会影响到尚未处理的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否为奇数  </span></span><br><span class="line">        vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i); <span class="comment">// 删除奇数位元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、方法二：使用迭代器并更新迭代器<br>当使用迭代器遍历vector时，如果删除元素，必须更新迭代器以避免悬挂迭代器。<br>不能使用vector的size，因为在删除后，size就改变了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  </span><br><span class="line"><span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否为奇数  </span></span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it); <span class="comment">// 删除元素并更新迭代器  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ++it; <span class="comment">// 只递增迭代器，不删除元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确释放vector的内存-clear-swap-shrink-to-fit"><a href="#正确释放vector的内存-clear-swap-shrink-to-fit" class="headerlink" title="正确释放vector的内存(clear(), swap(), shrink_to_fit())"></a>正确释放vector的内存(clear(), swap(), shrink_to_fit())</h2><p>vec.clear()：清空内容，但是不释放内存。<br>vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。<br>vec.shrink_to_fit()：请求容器降低其capacity和size匹配。<br>vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。</p><h2 id="vector如何释放空间"><a href="#vector如何释放空间" class="headerlink" title="vector如何释放空间?"></a>vector如何释放空间?</h2><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。<br>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</p><h2 id="为什么vector的插入操作可能会导致迭代器失效？"><a href="#为什么vector的插入操作可能会导致迭代器失效？" class="headerlink" title="为什么vector的插入操作可能会导致迭代器失效？"></a>为什么vector的插入操作可能会导致迭代器失效？</h2><p>vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。</p><h2 id="list的底层原理"><a href="#list的底层原理" class="headerlink" title="list的底层原理"></a>list的底层原理</h2><p>list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。<br>list不支持随机存取，适合需要大量的插入和删除，而不关心随即存取的应用场景。</p><h2 id="deque的底层原理"><a href="#deque的底层原理" class="headerlink" title="deque的底层原理"></a>deque的底层原理</h2><p>deque是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p><h2 id="什么情况下用vector，什么情况下用list，什么情况下用deque"><a href="#什么情况下用vector，什么情况下用list，什么情况下用deque" class="headerlink" title="什么情况下用vector，什么情况下用list，什么情况下用deque"></a>什么情况下用vector，什么情况下用list，什么情况下用deque</h2><p>vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。<br>list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。<br>需要从首尾两端进行插入或删除操作的时候需要选择deque。</p><h2 id="map-、set、multiset、multimap的底层原理"><a href="#map-、set、multiset、multimap的底层原理" class="headerlink" title="map 、set、multiset、multimap的底层原理"></a>map 、set、multiset、multimap的底层原理</h2><p>map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。</p><h2 id="map-、set、multiset、multimap的特点"><a href="#map-、set、multiset、multimap的特点" class="headerlink" title="map 、set、multiset、multimap的特点"></a>map 、set、multiset、multimap的特点</h2><p>set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。<br>map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。<br>map和set的增删改查速度为都是logn，是比较高效的。</p><h2 id="为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？"><a href="#为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？" class="headerlink" title="为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？"></a>为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？</h2><p>因为存储的是结点，不需要内存拷贝和内存移动。<br>因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。</p><h2 id="为何map和set不能像vector一样有个reserve函数来预分配数据"><a href="#为何map和set不能像vector一样有个reserve函数来预分配数据" class="headerlink" title="为何map和set不能像vector一样有个reserve函数来预分配数据?"></a>为何map和set不能像vector一样有个reserve函数来预分配数据?</h2><p>因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map&lt;Key, Data, Compare, Alloc&gt;声明的时候从参数中传入的Alloc。</p><h2 id="unordered-map、unordered-set的底层原理"><a href="#unordered-map、unordered-set的底层原理" class="headerlink" title="unordered_map、unordered_set的底层原理"></a>unordered_map、unordered_set的底层原理</h2><p>unordered_map的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。<br>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得每个元素的key都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。<br>但是，不能够保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 一般可采用拉链法解决冲突</p><h2 id="unordered-map-与map的区别？使用场景？"><a href="#unordered-map-与map的区别？使用场景？" class="headerlink" title="unordered_map 与map的区别？使用场景？"></a>unordered_map 与map的区别？使用场景？</h2><p>构造函数：unordered_map 需要hash函数，等于函数;map只需要比较函数(小于函数).<br>存储结构：unordered_map 采用hash表存储，map一般采用红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。</p><p>总体来说，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，unordered_map 可能会让你陷入尴尬，特别是当你的unordered_map 对象特别多时，你就更无法控制了，而且unordered_map 的构造速度较慢。</p><h2 id="容器内部删除一个元素"><a href="#容器内部删除一个元素" class="headerlink" title="容器内部删除一个元素"></a>容器内部删除一个元素</h2><ol><li>顺序容器（序列式容器，比如vector、deque）<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；<br>It &#x3D; c.erase(it);</li><li>关联容器(关联式容器，比如map、set、multimap、multiset等)<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；<br>c.erase(it++)</li></ol><h2 id="vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h2><ol><li>通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</li><li>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</li><li>erase()函数，只能删除内容，不能改变容量大小;<br>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</li></ol><h2 id="map中-与find的区别？"><a href="#map中-与find的区别？" class="headerlink" title="map中[ ]与find的区别？"></a>map中[ ]与find的区别？</h2><ol><li>map的下标运算符[ ]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li><li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。<br>频繁对vector调用push_back()对性能的影响和原因？<br>在一个vector的尾部之外的任何位置添加元素，都需要重新移动元素。而且，向一个vector添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间。</li></ol><h2 id="请你来介绍一下-STL-的空间配置器（allocator）"><a href="#请你来介绍一下-STL-的空间配置器（allocator）" class="headerlink" title="请你来介绍一下 STL 的空间配置器（allocator）"></a>请你来介绍一下 STL 的空间配置器（allocator）</h2><p>一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++  STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。</p><h2 id="说说-push-back-和-emplace-back-的区别"><a href="#说说-push-back-和-emplace-back-的区别" class="headerlink" title="说说 push_back 和 emplace_back 的区别"></a>说说 push_back 和 emplace_back 的区别</h2><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。<br>push_back 会创建一个新的对象，然后将其拷贝或移动到向量中，而 emplace_back 会直接在向量末尾构造对象，避免额外的拷贝或移动操作。</p><h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="简述-C-右值引用与转移语义"><a href="#简述-C-右值引用与转移语义" class="headerlink" title="简述 C++ 右值引用与转移语义"></a>简述 C++ 右值引用与转移语义</h2><p>右值引用</p><ol><li>一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。 </li><li>右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数<br>转移语义</li><li>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。</li></ol><h2 id="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"><a href="#什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？" class="headerlink" title="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"></a>什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？</h2><p>智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。<br>智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。<br>分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种，各自的特点： </p><ol><li>对于auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在C++11中被摒弃，其主要问题在于：</li></ol><ul><li>对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；</li><li>不能指向数组，也不能作为STL容器的成员。</li></ul><ol start="2"><li>对于unique_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">5</span>))</span></span>;  </span><br><span class="line">    ptr-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它会自动删除它所指向的MyClass对象  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于shared_ptr，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">5</span>);  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  <span class="comment">// ptr1和ptr2现在共享同一个MyClass对象  </span></span><br><span class="line">    ptr1-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    ptr2-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    <span class="comment">// 当ptr1和ptr2都离开作用域时，它们共享的MyClass对象才会被删除  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">5</span>);  </span><br><span class="line">    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr;  </span><br><span class="line">    <span class="comment">// 在某些情况下，可以使用weakPtr.lock()来获取一个临时的shared_ptr  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tempPtr = weakPtr.<span class="built_in">lock</span>()) &#123;  </span><br><span class="line">        tempPtr-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它会自动删除它所指向的MyClass对象，此时weakPtr变为无效  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。同时，weak_ptr 必须从一个share_ptr或者另一个weak_ptr转换而来，不能使用new 对象进行构造。由于弱引用不更改引用计数，类似普通指针，只要把循环引用的一方使用弱引用，即可解除循环引用。<br>循环引用例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;B&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;A&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">        pa-&gt;ptr = pb;</span><br><span class="line">        pb-&gt;ptr = pa;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出A和B，没有输出~A和~B</span></span><br></pre></td></tr></table></figure><!--/img/C++八股文/shareptr1.png --><img src="/img/C++%E5%85%AB%E8%82%A1%E6%96%87/shareptr1.png" alt="efae464a622aa5aaef5cdcb980f79a9f.png"><br>对象A同时被pa和对象B中的ptr两个智能指针托管，所以引用计数为2；对象B同时被pb和对象A中的ptr两个智能指针托管，所以引用计数也为2。那么当fun函数执行完，栈对象pb、pa依次开始执行析构函数<br>紧接着内存布局就变成了这样：<!--/img/C++八股文/shareptr2.png --><img src="/img/C++%E5%85%AB%E8%82%A1%E6%96%87/shareptr2.png" alt="d7d06697792031251d61625acbcc4094.png"><br>pa和pb已经销毁了，然而对象A和B，已经迷失在这浩瀚内存中，亘古难灭。称之为循环引用<br>为了解决shared_ptr在在循环引用中存在的资源泄漏问题，weak_ptr在这种场景下应用而生，weak_ptr指向的智能指针对象，其引用计数不会加一，也就不会存在无法释放的问题了。<br>解决的方法就是，把A和B其中的一个ptr改成weak_ptr。</li></ol><h2 id="简述一下-C-11-中四种类型转换"><a href="#简述一下-C-11-中四种类型转换" class="headerlink" title="简述一下 C++11 中四种类型转换"></a>简述一下 C++11 中四种类型转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>1、const_cast</p><ul><li>用于将const变量转为非const</li><li>const_cast 用于增加或去除类型的 const 或 volatile 属性。它常常被用于调用一些需要非 const 参数的函数，而实际传入的参数却是 const 的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a); <span class="comment">// 去除 const 属性  </span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 未定义行为，因为 a 本质上是 const 的</span></span><br></pre></td></tr></table></figure>2、static_cast</li><li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；<br>static_cast 用于基础数据类型之间的转换（如 int、float、double 等）、非多态类型之间的转换、空指针和空指针之间的转换，以及同一个继承层次内部类之间的转换。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;  </span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// int 到 float 的转换  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line"><span class="type">char</span>* non_const_str = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(str); <span class="comment">// 去除 const 修饰</span></span><br></pre></td></tr></table></figure>3、dynamic_cast<br>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</li><li>向上转换：指的是子类向基类的转换</li><li>向下转换：指的是基类向子类的转换<br>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。<br>dynamic_cast 主要用于类层次间的向上和向下转换，主要在运行时检查转换的有效性。它通常用于将基类指针转换为派生类指针或引用。如果转换不可能进行（即不是有效的向下转换），dynamic_cast 将返回空指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived instance&quot;</span> &lt;&lt; std::endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();  </span><br><span class="line">    Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  </span><br><span class="line">    <span class="keyword">if</span> (derived) &#123;  </span><br><span class="line">        derived-&gt;<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Derived instance&quot;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">delete</span> base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>4、reinterpret_cast</li><li>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；<br>reinterpret_cast 提供了一种在不同类型的指针或整数类型之间转换的低级别方式。这种转换不执行任何类型检查或格式转换，仅仅是重新解释位模式，因此它是非常不安全的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345</span>;  </span><br><span class="line"><span class="type">int</span>* p_int = &amp;a;  </span><br><span class="line"><span class="type">char</span>* p_char = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p_int); <span class="comment">// int* 到 char* 的转换</span></span><br></pre></td></tr></table></figure>5、为什么不使用C的强制转换？</li><li>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li></ul><h2 id="简述一下-C-11-中-auto-的具体用法"><a href="#简述一下-C-11-中-auto-的具体用法" class="headerlink" title="简述一下 C++ 11 中 auto 的具体用法"></a>简述一下 C++ 11 中 auto 的具体用法</h2><p>auto用于定义变量，编译器可以自动判断变量的类型。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="makefile和cmake"><a href="#makefile和cmake" class="headerlink" title="makefile和cmake"></a>makefile和cmake</h2><p>CMake和Makefile都是用于自动化构建和管理项目的工具，但它们之间存在一些显著的区别。<br>1、makefile<br>（1）Makefile是一种文件，它定义了一个项目中的编译规则、依赖关系和构建过程。<br>（2）它通常用于编译源代码、链接对象文件以生成可执行文件或库文件。<br>（3）Makefile的语法较为低级，需要手动编写规则和依赖关系。<br>其核心思想是根据文件的最后修改时间来确定哪些部分需要重新编译，以及以什么顺序来执行编译步骤。每个规则由一个目标（target）和一组依赖项（dependencies）组成，以及执行指令（commands）。Makefile的缺点是跨平台性较差，通常需要为特定平台和编译器编写，因此，当项目需要在不同平台上构建时，可能需要多个Makefile文件。<br>2、CMake<br>（1）CMake是一个跨平台的安装（编译）工具，它使用简单的语句来描述所有平台的安装（编译）过程。<br>（2）CMake能够输出各种各样的Makefile或者其他类型的项目文件，如Visual   Studio项目文件、Ninja构建文件等。这使得项目可以使用不同的构建系统来构建，而不必更改CMakeLists.txt文件。<br>（3）CMake并不直接构建出最终的软件，而是产生标准的构建文件，然后再依一般的构建方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式构建软件。<br>（4）CMake的组态档通常命名为CMakeLists.txt。<br>总结来说，CMake和Makefile的主要区别在于跨平台性、生成的文件类型以及使用的便捷性。CMake具有更好的跨平台性，可以生成多种类型的构建文件，而Makefile则更适用于特定平台和编译器的构建。在使用上，CMake通过更高级别的语句来描述构建过程，使得编写和维护构建规则更为便捷。而Makefile则需要手动编写相对低级的语法，因此在构建复杂项目时可能会更为繁琐。<br>例子：<br>1、CMake<br>首先，创建一个名为CMakeLists.txt的文件，这个文件描述了如何构建你的项目。对于我们的简单例子，CMakeLists.txt可能如下所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定CMake的最低版本要求  </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置项目名称  </span></span><br><span class="line"><span class="keyword">project</span>(MyProject)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置C++标准  </span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)  </span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加源文件到可执行文件  </span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject main.cpp)</span><br></pre></td></tr></table></figure><p>在这个文件中，我们指定了CMake的最低版本要求，设置了项目名称，并设置了C++标准。最后，我们使用add_executable命令将源文件main.cpp添加到一个名为MyProject的可执行文件中。<br>接下来，你需要在项目目录中创建一个名为build的子目录（或者任何你喜欢的名称），并在这个子目录中运行CMake来生成构建文件。在命令行中执行以下命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build  </span><br><span class="line">cd build  </span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这里的cmake ..命令告诉CMake从上一级目录（..）中的CMakeLists.txt文件读取构建指令。CMake将生成Makefile或其他构建系统文件（取决于你的平台和配置）。<br>一旦CMake运行成功，你就可以使用生成的构建文件来构建你的项目了。在Unix-like系统中（包括Linux和macOS），你可以使用make命令来构建项目：<br><code>make</code><br>这将编译main.cpp并链接生成可执行文件MyProject。在Windows系统中，如果你使用的是Visual Studio的生成器，那么可以直接打开生成的解决方案文件（通常是.sln文件）并在IDE中构建项目。<br>构建完成后，你可以在build目录中找到生成的可执行文件MyProject，并运行它<br>2、makefile<br>创建一个名为Makefile的文件，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义编译器  </span></span><br><span class="line">CC=gcc  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义编译器参数  </span></span><br><span class="line">CFLAGS=-Wall  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义源文件  </span></span><br><span class="line">SRCS=main.c  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义目标文件，将源文件后缀替换为.o  </span></span><br><span class="line">OBJS=$(SRCS:.c=.o)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义最终生成的可执行文件名  </span></span><br><span class="line">TARGET=myprogram  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 默认目标，即make命令不带任何参数时的目标  </span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 生成可执行文件的规则  </span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span>  </span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 生成目标文件的规则，%.o: %.c 表示所有的.o文件都依赖于相应的.c文件  </span></span><br><span class="line"><span class="section">%.o: %.c  </span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清除所有编译生成的文件  </span></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">        rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>在这个Makefile中：</p><ul><li>CC 和 CFLAGS 分别定义了使用的编译器和编译器的标志。</li><li>SRCS 包含了所有源文件。</li><li>OBJS 通过将源文件列表中的.c后缀替换为.o来生成目标文件列表。</li><li>TARGET 是最终生成的可执行文件的名称。</li><li>all 是默认目标，它依赖于$(TARGET)，即当执行make命令时不带任何参数时，会构建可执行文件。</li><li>$$(TARGET): $$(OBJS) 规则表示要生成可执行文件，需要所有的目标文件。</li><li>%.o: %.c 是一个模式规则，它告诉make如何将每个.c源文件编译成相应的.o目标文件。</li><li>clean 目标是一个伪目标（不以文件命名的目标），用于删除所有编译生成的文件。<br>现在，你可以在命令行中执行以下命令来构建你的项目：<br><code>make</code><br>这将编译main.c文件，生成main.o目标文件，并链接生成myprogram可执行文件。<br>如果你想要清除编译生成的所有文件，可以执行：<br><code>make clean</code><br>这将删除所有的.o目标文件和myprogram可执行文件。<br>这个Makefile构建例子是非常基础的，但展示了Makefile的基本结构和一些常用的规则。对于更复杂的项目，Makefile可能会包含更多的源文件、依赖的库、安装规则等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
